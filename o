292ae658 (Ben Reber  2021-07-15 16:19:22 -0400    1) // Functions for parsing input files, debug prints, 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400    2) // and lease output
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500    3) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400    4) pub mod io {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400    5)     use serde::{Serialize, Deserialize};
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400    6)     use std::collections::BinaryHeap;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400    7)     use std::collections::HashMap;
8cf770ac (matthew    2021-09-11 00:40:05 -0400    8)     use std::io::Write;
465fad7c (matthew    2022-01-20 14:01:55 -0500    9)     use std::convert::TryInto;
465fad7c (matthew    2022-01-20 14:01:55 -0500   10)     use std::fs::File;
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400   11) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   12)     #[derive(Deserialize)]
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   13)     #[derive(Debug)]
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   14)     struct Sample{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   15)         phase_id_ref: String,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   16)         ri: String,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   17)         tag: String,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   18)         time: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   19)     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   20) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   21)     #[derive(Serialize)]
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   22)     struct PhaseTime{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   23)         phase_id: u16,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   24)         start_time: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400   25)     }
614408e5 (matthew    2021-11-10 23:51:03 -0500   26)     pub fn get_binned_hists(input_file:&str, num_bins: u64,set_mask:  u32) -> (super::lease_gen::BinnedRIs,super::lease_gen::BinFreqs,u64){
eff726b1 (matthew    2021-09-09 01:24:16 -0400   27) 
eff726b1 (matthew    2021-09-09 01:24:16 -0400   28)         let mut curr_bin: u64= 0;
eff726b1 (matthew    2021-09-09 01:24:16 -0400   29)         let mut curr_bin_dict=HashMap::<u64,u64>::new();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   30)         let mut bin_freqs=HashMap::<u64,HashMap<u64,u64>>::new();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   31)         let mut bin_ri_distributions=HashMap::<u64,HashMap<u64,HashMap<u64,u64>>>::new();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   32)         let mut curr_ri_distribution_dict=HashMap::<u64,HashMap<u64,u64>>::new();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   33)         let mut last_address: u64 =0;
eff726b1 (matthew    2021-09-09 01:24:16 -0400   34)         let mut all_keys: Vec<u64>=Vec::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500   35)         
eff726b1 (matthew    2021-09-09 01:24:16 -0400   36)         bin_freqs.insert(0,curr_bin_dict.clone());
eff726b1 (matthew    2021-09-09 01:24:16 -0400   37)         bin_ri_distributions.insert(0,curr_ri_distribution_dict.clone());
eff726b1 (matthew    2021-09-09 01:24:16 -0400   38)        
eff726b1 (matthew    2021-09-09 01:24:16 -0400   39)         let mut rdr = csv::ReaderBuilder::new()
eff726b1 (matthew    2021-09-09 01:24:16 -0400   40)             .has_headers(false)
eff726b1 (matthew    2021-09-09 01:24:16 -0400   41)             .from_path(input_file)
eff726b1 (matthew    2021-09-09 01:24:16 -0400   42)             .unwrap();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   43)         for result in rdr.deserialize() {
eff726b1 (matthew    2021-09-09 01:24:16 -0400   44)             let sample: Sample = result.unwrap();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   45)             last_address= sample.time;
eff726b1 (matthew    2021-09-09 01:24:16 -0400   46)         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400   47)         let bin_width = ((last_address as f64 / (num_bins as f64)) as f64).ceil() as u64;
eff726b1 (matthew    2021-09-09 01:24:16 -0400   48)         let mut rdr = csv::ReaderBuilder::new()
eff726b1 (matthew    2021-09-09 01:24:16 -0400   49)             .has_headers(false)
eff726b1 (matthew    2021-09-09 01:24:16 -0400   50)             .from_path(input_file)
eff726b1 (matthew    2021-09-09 01:24:16 -0400   51)             .unwrap();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   52)         for result in rdr.deserialize(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400   53)             let sample: Sample = result.unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500   54) 
eff726b1 (matthew    2021-09-09 01:24:16 -0400   55)             
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   56)             //if outside of current bin, moved to the next
eff726b1 (matthew    2021-09-09 01:24:16 -0400   57)             if sample.time>curr_bin+bin_width{
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   58)               //store the RI and frequency data for the old bin
eff726b1 (matthew    2021-09-09 01:24:16 -0400   59)                 bin_freqs.insert(curr_bin,curr_bin_dict.clone());
eff726b1 (matthew    2021-09-09 01:24:16 -0400   60)                 bin_ri_distributions.insert(curr_bin,curr_ri_distribution_dict.clone());
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   61)                 //initalize storage for the new bin
eff726b1 (matthew    2021-09-09 01:24:16 -0400   62)                 curr_bin_dict.clear();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   63)                 curr_ri_distribution_dict.clear();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   64)                 curr_bin+=bin_width;
eff726b1 (matthew    2021-09-09 01:24:16 -0400   65) 
eff726b1 (matthew    2021-09-09 01:24:16 -0400   66)             }
614408e5 (matthew    2021-11-10 23:51:03 -0500   67)             let tag = u32::from_str_radix(&sample.tag,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500   68)                 let set = (tag&set_mask) as u64;
614408e5 (matthew    2021-11-10 23:51:03 -0500   69)                 
614408e5 (matthew    2021-11-10 23:51:03 -0500   70)             let addr = u64::from_str_radix(&sample.phase_id_ref,16).unwrap()|(set<<32);
eff726b1 (matthew    2021-09-09 01:24:16 -0400   71)             let ri = u64::from_str_radix(&sample.ri,16).unwrap();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   72)             
eff726b1 (matthew    2021-09-09 01:24:16 -0400   73)             if curr_bin_dict.contains_key(&addr){
eff726b1 (matthew    2021-09-09 01:24:16 -0400   74)                 curr_bin_dict.insert(addr,curr_bin_dict.get(&addr).unwrap()+1);
eff726b1 (matthew    2021-09-09 01:24:16 -0400   75)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400   76)             else {
eff726b1 (matthew    2021-09-09 01:24:16 -0400   77)                 curr_bin_dict.insert(addr,1);
eff726b1 (matthew    2021-09-09 01:24:16 -0400   78)             }
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   79)             //if the address isn't a key in the outer level hashmap, add a hashmap corresponding to that key; then add the key value pair (ri,1) to that hashmap
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   80)             //if the address is a key in the outer level hashmap, check to see if the current ri is a key in the corresponding inner hashmap.
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   81)             //if yes, then increment the count for that RI, if not, insert a new key value pair (ri,1).
eff726b1 (matthew    2021-09-09 01:24:16 -0400   82)            *curr_ri_distribution_dict.entry(addr).or_insert(HashMap::new()).entry(ri).or_insert(0) += 1;
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   83) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   84)            //create an array of all found references
eff726b1 (matthew    2021-09-09 01:24:16 -0400   85)             if !all_keys.iter().any(|&i| i==addr){
eff726b1 (matthew    2021-09-09 01:24:16 -0400   86)                 all_keys.push(addr);
eff726b1 (matthew    2021-09-09 01:24:16 -0400   87)             }
614408e5 (matthew    2021-11-10 23:51:03 -0500   88)                 
eff726b1 (matthew    2021-09-09 01:24:16 -0400   89)         }
614408e5 (matthew    2021-11-10 23:51:03 -0500   90)        
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   91)         //store the frequency and RI data for the last bin
eff726b1 (matthew    2021-09-09 01:24:16 -0400   92)         bin_freqs.insert(curr_bin,curr_bin_dict.clone());
eff726b1 (matthew    2021-09-09 01:24:16 -0400   93)         bin_ri_distributions.insert(curr_bin,curr_ri_distribution_dict.clone());
3dcbac4c (matthew    2021-09-12 18:06:29 -0400   94)         //if a reference is not in a bin, add it with a frequency count of 0
eff726b1 (matthew    2021-09-09 01:24:16 -0400   95)         let temp= bin_freqs.clone();
eff726b1 (matthew    2021-09-09 01:24:16 -0400   96)         for (bin,_addrs) in &temp{
eff726b1 (matthew    2021-09-09 01:24:16 -0400   97)             let bin_freqs_temp=bin_freqs.entry(*bin).or_insert(HashMap::new());
eff726b1 (matthew    2021-09-09 01:24:16 -0400   98)             for key in &all_keys{
eff726b1 (matthew    2021-09-09 01:24:16 -0400   99)                 bin_freqs_temp.entry(*key).or_insert(0);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  100)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  101)         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  102)         (super::lease_gen::BinnedRIs::new(bin_ri_distributions),super::lease_gen::BinFreqs::new(bin_freqs),bin_width)
eff726b1 (matthew    2021-09-09 01:24:16 -0400  103)     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  104) 
614408e5 (matthew    2021-11-10 23:51:03 -0500  105)     pub fn build_phase_transitions(input_file:&str) -> (Vec<(u64,u64)>,usize,u64){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  106)         println!("Reading input from: {}", input_file);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  107)         let mut rdr = csv::ReaderBuilder::new()
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  108)             .has_headers(false)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  109)             .from_path(input_file)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  110)             .unwrap();
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  111)         let mut u_tags=HashMap::<u64,bool>::new();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  112)         let mut sample_hash = HashMap::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500  113)         let mut last_sample_time: u64=0;
614408e5 (matthew    2021-11-10 23:51:03 -0500  114)         let mut sample_num: u64=0;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  115)         for result in rdr.deserialize() {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  116)             let sample: Sample = result.unwrap();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  117)             let ri = u64::from_str_radix(&sample.ri,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  118)             //don't use end of benchmark infinite RIs
614408e5 (matthew    2021-11-10 23:51:03 -0500  119) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  120)             //store unique tags
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  121)              u_tags.insert(u64::from_str_radix(&sample.tag,16).unwrap(),false);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  122)             let phase_id_ref = u64::from_str_radix(&sample.phase_id_ref,16).unwrap();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  123)             let phase_id = (phase_id_ref & 0xFF000000)>>24;
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  124)             let reuse_time = sample.time;
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  125)             let use_time;
20d01f90 (matthew    2021-10-10 19:48:45 -0400  126)             if (ri as i32)<0 {
20d01f90 (matthew    2021-10-10 19:48:45 -0400  127)                use_time=reuse_time -(!ri+1)as u64;
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  128)             }
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  129)             else{
20d01f90 (matthew    2021-10-10 19:48:45 -0400  130)                 use_time = reuse_time - ri as u64;
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  131)             }
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  132)             sample_hash.insert(use_time,phase_id);
614408e5 (matthew    2021-11-10 23:51:03 -0500  133)             //get empircal sampling rate
614408e5 (matthew    2021-11-10 23:51:03 -0500  134)             last_sample_time=sample.time;
614408e5 (matthew    2021-11-10 23:51:03 -0500  135)             sample_num+=1;
614408e5 (matthew    2021-11-10 23:51:03 -0500  136) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  137)         }
614408e5 (matthew    2021-11-10 23:51:03 -0500  138)         //empircally calculate sampling rate
614408e5 (matthew    2021-11-10 23:51:03 -0500  139)         let sampling_rate=(last_sample_time as f64/sample_num as f64).round() as u64;
465fad7c (matthew    2022-01-20 14:01:55 -0500  140)         println!("empirical sampling_rate:{}",sampling_rate);
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  141)         //every data block is associated with at least one miss in the absense of hardware prefetching.
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  142)         let first_misses=u_tags.len();
177a91f6 (matthew    2021-09-25 04:20:29 -0400  143)        
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  144) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  145)         let mut sorted_samples: Vec<_> = sample_hash.iter().collect();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  146)         sorted_samples.sort_by_key(|a| a.0);
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  147) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  148)         //get phase transitions
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  149)         let mut phase_transitions = HashMap::new(); //(time,phase start)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  150)         let mut phase = 0;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  151)         phase_transitions.insert(0,phase);
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  152) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  153)         for s in sorted_samples.iter(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  154)             if *s.1 != phase{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  155)                 phase_transitions.insert(*s.0,*s.1);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  156)                 phase = *s.1;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  157)             } 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  158)         }
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400  159) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  160)         let mut sorted_transitions: Vec<_> = phase_transitions.iter().collect();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  161)         sorted_transitions.sort_by_key(|a| a.0);
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400  162) 
614408e5 (matthew    2021-11-10 23:51:03 -0500  163)         return(sorted_transitions.iter().map(|&x| (*(x.0),*(x.1))).collect(),first_misses,sampling_rate);
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  164)       
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  165)     }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  166) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  167)     //Build ri hists in the following form
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  168)     //{ref_id,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  169)     //  {ri,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  170)     //    (count,{phase_id,(head_cost,tail_cost)})}}
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  171)     //
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  172)     // Head cost refers to the accumulation of 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  173)     // cost from reuses with length ri, which may span 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  174)     // phase boundaries.
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  175)     
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  176)     // Tail cost refers to the accumulation of cost from reuses greater than ri.
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  177)     // This cost may span a phase boundary 
614408e5 (matthew    2021-11-10 23:51:03 -0500  178)     pub fn build_ri_hists(input_file:&str,cshel:bool,set_mask:u32) -> (super::lease_gen::RIHists,HashMap<u64,u64>,usize,u64){
614408e5 (matthew    2021-11-10 23:51:03 -0500  179)         let (phase_transitions,first_misses,sampling_rate) = build_phase_transitions(input_file);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  180)         let mut rdr = csv::ReaderBuilder::new()
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  181)             .has_headers(false)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  182)             .from_path(input_file)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  183)             .unwrap();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  184) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  185)         let mut ri_hists = HashMap::new();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  186)         let mut samples_per_phase = HashMap::new();
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  187)      
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  188)         //Don't need to calculate head or tail costs for PRL or CLAM or SHEL, 
09c93cae (matthew    2021-09-29 22:21:41 -0400  189)      
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  190) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  191)         if cshel {
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  192)             println!("before first pass!");
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  193)             for result in rdr.deserialize() {
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  194)                 let sample: Sample = result.unwrap();
20d01f90 (matthew    2021-10-10 19:48:45 -0400  195)                 let ri = u32::from_str_radix(&sample.ri,16).unwrap();
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  196)                 let reuse_time = sample.time;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  197)                 let use_time;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  198) 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  199)                 let mut ri_signed = ri as i32;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  200) 
20d01f90 (matthew    2021-10-10 19:48:45 -0400  201)                  if ri_signed < 0 {
20d01f90 (matthew    2021-10-10 19:48:45 -0400  202)                    use_time=reuse_time -(!ri_signed+1)as u64;
465fad7c (matthew    2022-01-20 14:01:55 -0500  203)                     ri_signed = 16777215; //canonical value for negatives
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  204)                 }
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  205)                 else {
20d01f90 (matthew    2021-10-10 19:48:45 -0400  206)                     use_time = reuse_time - ri_signed as u64;
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  207)                 }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  208) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  209)                 let phase_id_ref = u64::from_str_radix(&sample.phase_id_ref,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  210)                 
614408e5 (matthew    2021-11-10 23:51:03 -0500  211)                  let tag = u32::from_str_radix(&sample.tag,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  212)                 let set = (tag&set_mask) as u64;
614408e5 (matthew    2021-11-10 23:51:03 -0500  213)                 let set_phase_id_ref=phase_id_ref | set<<32;
614408e5 (matthew    2021-11-10 23:51:03 -0500  214) 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  215)                 let next_phase_tuple = match super::helpers::binary_search(&phase_transitions,use_time){
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  216)                     Some(v) => v,
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  217)                     None => (reuse_time+1,0),
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  218)                 };
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  219)                 super::lease_gen::process_sample_head_cost(&mut ri_hists,
614408e5 (matthew    2021-11-10 23:51:03 -0500  220)                                                        set_phase_id_ref,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  221)                                                        ri_signed as u64,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  222)                                                        use_time,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  223)                                                        next_phase_tuple);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  224) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  225)                 let phase_id = (phase_id_ref & 0xFF000000)>>24;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  226)                 *samples_per_phase.entry(phase_id).or_insert_with(|| 0)+=1;
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  227)             }
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  228)             
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  229)             let mut rdr = csv::ReaderBuilder::new()
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  230)                 .has_headers(false)
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  231)                 .from_path(input_file)
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  232)                 .unwrap();
09c93cae (matthew    2021-09-29 22:21:41 -0400  233)                    println!("before second pass!");
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  234)             //second pass for tail costs
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  235)             for result in rdr.deserialize() {
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  236)                 let sample: Sample = result.unwrap();
20d01f90 (matthew    2021-10-10 19:48:45 -0400  237)                 let ri = u32::from_str_radix(&sample.ri,16).unwrap();
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  238) 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  239)                 let reuse_time = sample.time;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  240)                 let use_time;
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  241) 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  242)                 let mut ri_signed = ri as i32;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  243) 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  244)                 if ri_signed < 0 {
20d01f90 (matthew    2021-10-10 19:48:45 -0400  245)                    use_time=reuse_time -(!ri_signed+1)as u64;
465fad7c (matthew    2022-01-20 14:01:55 -0500  246)                     ri_signed = 16777215; //canonical value for negatives
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  247)                 }
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  248)                 else {
20d01f90 (matthew    2021-10-10 19:48:45 -0400  249)                     use_time = reuse_time - ri_signed as u64;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  250)                 }
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  251) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  252)                 let phase_id_ref = u64::from_str_radix(&sample.phase_id_ref,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  253)                 let tag = u32::from_str_radix(&sample.tag,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  254)                 let set = (tag&set_mask) as u64;
614408e5 (matthew    2021-11-10 23:51:03 -0500  255)                 let set_phase_id_ref=phase_id_ref | set<<32;
177a91f6 (matthew    2021-09-25 04:20:29 -0400  256)                
38fb6c73 (matthew    2021-09-24 00:05:14 -0400  257)                 let next_phase_tuple = match super::helpers::binary_search(&phase_transitions,use_time){
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  258)                     Some(v) => v,
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  259)                     None => (reuse_time+1,0),
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  260)                 };
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  261) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  262)                 super::lease_gen::process_sample_tail_cost(&mut ri_hists,
614408e5 (matthew    2021-11-10 23:51:03 -0500  263)                                          set_phase_id_ref,
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  264)                                          ri_signed as u64,
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  265)                                          use_time,
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  266)                                          next_phase_tuple);
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  267)             }
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  268)         }
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  269)         //if not doing C-SHEL generates RI distribution with head and tail costs set to 0 (significantly faster)
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  270)         else{
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  271)             for result in rdr.deserialize() {
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  272)                 let sample: Sample = result.unwrap();
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  273)                 let mut ri = u64::from_str_radix(&sample.ri,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  274)                 let _reuse_time = sample.time;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  275)                 //if sample is negative, there is no reuse 
465fad7c (matthew    2022-01-20 14:01:55 -0500  276)                  let ri_signed = ri as i32;
465fad7c (matthew    2022-01-20 14:01:55 -0500  277)                 if ri_signed < 0 {
465fad7c (matthew    2022-01-20 14:01:55 -0500  278)                     ri=16777215;
465fad7c (matthew    2022-01-20 14:01:55 -0500  279)                 }
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  280) 
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  281)                 let phase_id_ref = u64::from_str_radix(&sample.phase_id_ref,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  282)                 let tag = u32::from_str_radix(&sample.tag,16).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500  283)                 let set = (tag&set_mask) as u64;
614408e5 (matthew    2021-11-10 23:51:03 -0500  284)                 let set_phase_id_ref=phase_id_ref | set<<32;
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  285)                 let phase_id = (phase_id_ref & 0xFF000000)>>24;
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  286)                 *samples_per_phase.entry(phase_id).or_insert(0)+=1;
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  287)                 //if the reference isn't in the distrubtion add it
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  288)                 //if an ri for that reference isn't in the distrubtion add it as key with a value of (ri_count,{phaseID,(0,0)))
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  289)                 //if an ri for that reference is in the distribuntion increment the ri count by 1
614408e5 (matthew    2021-11-10 23:51:03 -0500  290)                ri_hists.entry(set_phase_id_ref).or_insert(HashMap::new()).entry(ri).and_modify(|e| {e.0+=1}).or_insert((1,HashMap::new())).1.entry(phase_id).or_insert((0,0));
898bb0b1 (matthew    2021-07-20 11:01:29 -0400  291)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  292)         }
614408e5 (matthew    2021-11-10 23:51:03 -0500  293)         (super::lease_gen::RIHists::new(ri_hists),samples_per_phase,first_misses,sampling_rate)
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  294)     }
8cf770ac (matthew    2021-09-11 00:40:05 -0400  295)     pub fn dump_leases(leases: HashMap<u64,u64>, 
177a91f6 (matthew    2021-09-25 04:20:29 -0400  296)         dual_leases: HashMap<u64,(f64,u64)>,
8cf770ac (matthew    2021-09-11 00:40:05 -0400  297)         lease_hits:HashMap<u64,HashMap<u64,u64>>,
8cf770ac (matthew    2021-09-11 00:40:05 -0400  298)         trace_length:u64,
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  299)         output_file:&str,
614408e5 (matthew    2021-11-10 23:51:03 -0500  300)         sampling_rate:u64,
20d01f90 (matthew    2021-10-10 19:48:45 -0400  301)         first_misses:usize) ->Vec<(u64,u64,u64,u64,f64)> {
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  302)         let mut num_hits=0;
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  303)         //create lease output vector
177a91f6 (matthew    2021-09-25 04:20:29 -0400  304)         let mut lease_vector: Vec<(u64,u64,u64,u64,f64)> = Vec::new();
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  305)         for (&phase_address,&lease) in leases.iter() {
69e781b9 (matthew    2021-07-20 15:12:00 -0400  306)             let lease = if lease >0 {lease} else {1}; 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  307)             let phase   = (phase_address & 0xFF000000)>>24;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  308)             let address =  phase_address & 0x00FFFFFF;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  309)             if dual_leases.contains_key(&phase_address){
69e781b9 (matthew    2021-07-20 15:12:00 -0400  310)                lease_vector.push((phase,address,lease,dual_leases.get(&phase_address).unwrap().1,1.0-dual_leases.get(&phase_address).unwrap().0));
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  311)             }
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  312)             else {
69e781b9 (matthew    2021-07-20 15:12:00 -0400  313)                 lease_vector.push((phase,address,lease,0, 1.0));
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  314)             }
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  315)         } 
eff726b1 (matthew    2021-09-09 01:24:16 -0400  316)         lease_vector.sort_by_key(|a| (a.0,a.1)); //sort by phase and then by reference
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  317)         //get number of predicted misses
465fad7c (matthew    2022-01-20 14:01:55 -0500  318)         for (phase, address, lease_short, lease_long, percentage) in lease_vector.iter(){
3e08d753 (matthew    2021-09-10 20:54:51 -0400  319)             
465fad7c (matthew    2022-01-20 14:01:55 -0500  320)             //reassemble phase address
465fad7c (matthew    2022-01-20 14:01:55 -0500  321)             let phase_address=address|phase<<24;
3e08d753 (matthew    2021-09-10 20:54:51 -0400  322)             //we are assuming that our sampling captures all RIS by assuming the distribution is normal
3e08d753 (matthew    2021-09-10 20:54:51 -0400  323)             //thus if an RI for a reference didn't occur during runtime (i.e., the base lease of 1 that all references get) 
465fad7c (matthew    2022-01-20 14:01:55 -0500  324)             //we can assume the number of hits it gets is zero.
465fad7c (matthew    2022-01-20 14:01:55 -0500  325)             if lease_hits.get(&phase_address).unwrap().get(lease_short)!=None{
465fad7c (matthew    2022-01-20 14:01:55 -0500  326)                 num_hits+=(*lease_hits.get(&phase_address).unwrap().get(lease_short).unwrap() as f64 *(percentage)).round() as u64;
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  327)             }
465fad7c (matthew    2022-01-20 14:01:55 -0500  328)             if lease_hits.get(&phase_address).unwrap().get(lease_long)!=None{
465fad7c (matthew    2022-01-20 14:01:55 -0500  329)                 num_hits+=(*lease_hits.get(&phase_address).unwrap().get(lease_long).unwrap() as f64 *(1.0-percentage)).round() as u64;
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  330)             }
09c93cae (matthew    2021-09-29 22:21:41 -0400  331)             
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  332)          }
8cf770ac (matthew    2021-09-11 00:40:05 -0400  333)          println!("Writing output to: {}",output_file);
465fad7c (matthew    2022-01-20 14:01:55 -0500  334)          let mut file = File::create(output_file).expect("create failed");
614408e5 (matthew    2021-11-10 23:51:03 -0500  335)          file.write_all(&format!("Dump predicted miss count (no contention misses): {}\n",trace_length-num_hits*sampling_rate+first_misses as u64)[..].as_bytes()).expect("write failed");
8cf770ac (matthew    2021-09-11 00:40:05 -0400  336)          file.write_all("Dump formated leases\n".as_bytes()).expect("write failed");
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  337) 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  338)          for (phase, address, lease_short, lease_long, percentage) in lease_vector.iter(){
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  339)              file.write_all(&format!("{:x}, {:x}, {:x}, {:x}, {}\n",
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  340)                                      phase, 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  341)                                      address, 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  342)                                      lease_short, 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  343)                                      lease_long, 
6bc86ccd (Ben Reber  2021-09-15 14:08:02 -0400  344)                                      percentage)[..].as_bytes()).expect("write failed");
69e781b9 (matthew    2021-07-20 15:12:00 -0400  345)         }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  346)         return lease_vector;
20d01f90 (matthew    2021-10-10 19:48:45 -0400  347)     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  348)     // function for generating c-files
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  349)     pub fn gen_lease_c_file(mut lease_vector:Vec<(u64,u64,u64,u64,f64)>,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  350)                             llt_size:u64,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  351)                             max_num_scopes:u64,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  352)                             mem_size:u64,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  353)                             output_file:String,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  354)                             discretize_width:u64){
20d01f90 (matthew    2021-10-10 19:48:45 -0400  355)     
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  356)         let mut phase_lease_arr:HashMap<u64,HashMap<u64,(u64,u64,f64,bool)>> = HashMap::new();
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  357)         let mut phases:Vec<u64>=Vec::new();
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  358)         for lease in lease_vector.iter(){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  359)             if !phases.contains(&lease.0){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  360)                 phases.push(lease.0);
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  361)             }
614408e5 (matthew    2021-11-10 23:51:03 -0500  362)         }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  363)         //due to the way the lease cache operates, phases skipped 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  364)         //if there are phases with no leases, assign a dummy lease to the skipped phase
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  365)         //Since we have no way of knowing without adding 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  366)         //another dependency how many phases a program has
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  367)         //create dummy phases for all phases that can fit in memory that aren't represented
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  368)         for phase in 0..max_num_scopes{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  369)             if !phases.contains(&phase){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  370)                 lease_vector.push((phase,0,0,0,1.0));
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  371)             }
614408e5 (matthew    2021-11-10 23:51:03 -0500  372)         }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  373) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  374)         //convert lease vector to hashmap of leases per phase
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  375)         for (phase, address, lease_short, lease_long, percentage) in lease_vector.iter(){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  376)              phase_lease_arr.entry(*phase).or_insert(HashMap::new())
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  377)                  .entry(*address)
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  378)                  .or_insert((*lease_short,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  379)                              *lease_long,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  380)                              *percentage,
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  381)                              if lease_long >&0 {true} else {false})); 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  382)         }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  383)         let default_lease=1;
20d01f90 (matthew    2021-10-10 19:48:45 -0400  384) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  385)         //make sure each phase can fit in the specified LLT
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  386)         for (phase,phase_leases) in phase_lease_arr.iter(){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  387)             if phase_leases.len()>llt_size as usize {
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  388)                 println!("Leases for Phase {} don't fit in lease lookup table!",phase);
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  389)                 panic!();
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  390)             }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  391)         }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  392) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  393)         //make sure that all phases can fit in the memory allocated
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  394)         if *phases.iter().max().unwrap()>max_num_scopes{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  395)             println!("Error: phases cannot fit in specified {} byte memory",mem_size);
20d01f90 (matthew    2021-10-10 19:48:45 -0400  396)             panic!();
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  397)         }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  398) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  399)         //write header
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  400)         let mut file = std::fs::File::create(output_file).expect("create failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  401)         file.write_all("#include \"stdint.h\"\n\n".as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  402)         file.write_all(
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  403)             format!(
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  404)                 "static uint32_t lease[{}] __attribute__((section (\".lease\"))) __attribute__ ((__used__)) = {{\n",
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  405)                 mem_size/4)
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  406)             .as_bytes())
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  407)             .expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  408)         file.write_all("// lease header\n".as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  409)         let mut phase_index:u64=0;//len returns usize which can't directly substituted as u64
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  410)         for i in 0..phase_lease_arr.len(){
20d01f90 (matthew    2021-10-10 19:48:45 -0400  411)             let phase_leases=phase_lease_arr.get(&phase_index).unwrap();
20d01f90 (matthew    2021-10-10 19:48:45 -0400  412)             phase_index=phase_index+1; //increment to next phase
20d01f90 (matthew    2021-10-10 19:48:45 -0400  413)             file.write_all(format!("// phase {}\n",i).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  414)          
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  415)             let mut dual_lease_ref=(0,0,1.0);
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  416)             let mut lease_phase:Vec<(u64,u64)>=Vec::new();
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  417)             let dual_lease_found=false;
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  418)             for(lease_ref,lease_data) in phase_leases.iter(){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  419)                 //convert hashmap of leases for phase to vector
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  420)                 lease_phase.push((*lease_ref,lease_data.0));
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  421)                 //get dual lease if it exists;
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  422)                 if lease_data.3==true && dual_lease_found==false {
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  423)                     dual_lease_ref=(*lease_ref,lease_data.1,lease_data.2);
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  424)                 }          
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  425)            }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  426)            lease_phase.sort_by_key(|a| a.0);
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  427)            //output config
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  428)            for j in 0..16{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  429)                     if j==0{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  430)                      file.write_all(format!("\t0x{:08x},\t// default lease\n",default_lease).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  431)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  432)                     else if j==1{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  433)                       file.write_all(format!("\t0x{:08x},\t// long lease value\n",dual_lease_ref.1).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  434)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  435)                     else if j==2{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  436)                         file.write_all(format!("\t0x{:08x},\t// short lease probability\n",discretize(dual_lease_ref.2,discretize_width)).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  437)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  438)                     else if j==3{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  439)     file.write_all(format!("\t0x{:08x},\t// num of references in phase\n",phase_leases.len()).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  440)       
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  441)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  442)                     else if j==4{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  443)     file.write_all(format!("\t0x{:08x},\t// dual lease ref (word address)\n",dual_lease_ref.0>>2).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  444)       
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  445)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  446)                     else {
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  447)     file.write_all(format!("\t0x{:08x},\t // unused\n",0).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  448)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  449)             }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  450)             let field_list=["reference address","lease0 value"];
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  451)            
20d01f90 (matthew    2021-10-10 19:48:45 -0400  452) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  453)                 // loop through lease fields
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  454)             for k in 0..2{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  455)                 file.write_all(format!("\t//{}\n\t",field_list[k]).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  456)                 
20d01f90 (matthew    2021-10-10 19:48:45 -0400  457) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  458)                 for j in 0..llt_size{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  459)                     if j<phase_leases.len().try_into().unwrap(){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  460)                         if k==0 {
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  461)                             file.write_all(format!("0x{:08x}",lease_phase[j as usize].0).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  462)                         }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  463)                         else {
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  464)                             file.write_all(format!("0x{:08x}",lease_phase[j as usize].1).as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  465)                         }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  466)                     }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  467)                     else {
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  468)                         file.write_all(format!("0x{:08x}",0).as_bytes()).expect("write failed");
20d01f90 (matthew    2021-10-10 19:48:45 -0400  469)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  470)                     //print delimiter
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  471)                     if j+1==llt_size && k==1 && i+1 ==phase_lease_arr.len(){
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  472)                         file.write_all(format!("\n").as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  473)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  474)                     else if j+1==llt_size{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  475)                         file.write_all(format!(",\n").as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  476)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  477)                     else if ((j+1)%10)==0{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  478)                         file.write_all(format!(",\n\t").as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  479)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  480)                     else {
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  481)                         file.write_all(format!(", ").as_bytes()).expect("write failed");
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  482)                     }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  483)        
20d01f90 (matthew    2021-10-10 19:48:45 -0400  484)                 }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  485)             }
20d01f90 (matthew    2021-10-10 19:48:45 -0400  486) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  487)         }
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  488)       file.write_all(format!("}};").as_bytes()).expect("write failed");
20d01f90 (matthew    2021-10-10 19:48:45 -0400  489)     }
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  490) 
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  491)     pub fn discretize(percentage: f64,discretization:u64)->u64{
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  492)         let percentage_binary =((percentage*((2<<(discretization-1)) as f64)-1.0)).round() as u64;
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  493)         return percentage_binary;
6bb57787 (jammin-ben 2023-02-23 17:00:59 -0500  494)     }    
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  495)     
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  496)     pub mod debug {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  497)         pub fn print_ri_hists(rihists: &super::super::lease_gen::RIHists){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  498)             for (ref_id, ref_ri_hist) in &rihists.ri_hists{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  499)                 println!("({},0x{:x}):",(ref_id & 0xFF000000) >> 24, ref_id & 0x00FFFFFF);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  500)                 for (ri,tuple) in ref_ri_hist{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  501)                     println!(" | ri 0x{:x}: count {}",ri, tuple.0);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  502)                     for (phase_id,cost) in &tuple.1{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  503)                         println!(" | | phase {} head_cost {} tail_cost {}",
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  504)                                  phase_id,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  505)                                  cost.0,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  506)                                  cost.1);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  507)                     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  508)                 }
f90180c6 (Ben Reber  2021-07-01 13:13:02 -0400  509)             }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  510)         }
465fad7c (matthew    2022-01-20 14:01:55 -0500  511)         //<u64,HashMap<u64,HashMap<u64,u64>>>
465fad7c (matthew    2022-01-20 14:01:55 -0500  512)         pub fn print_binned_hists(binned_ris: &super::super::lease_gen::BinnedRIs){
465fad7c (matthew    2022-01-20 14:01:55 -0500  513)             for (bin, ref_ri_hist) in &binned_ris.bin_ri_distribution{
465fad7c (matthew    2022-01-20 14:01:55 -0500  514)                 println!("Bin:{}",bin);
465fad7c (matthew    2022-01-20 14:01:55 -0500  515)                 for (ref_id, ri_hist) in ref_ri_hist{
465fad7c (matthew    2022-01-20 14:01:55 -0500  516)                     println!(" | ref 0x{:x}:",ref_id);
465fad7c (matthew    2022-01-20 14:01:55 -0500  517)                     for (ri,count) in ri_hist{
465fad7c (matthew    2022-01-20 14:01:55 -0500  518)                         println!(" | | ri 0x{:x}: count {}",ri,count);
465fad7c (matthew    2022-01-20 14:01:55 -0500  519)                     }
465fad7c (matthew    2022-01-20 14:01:55 -0500  520)                 }
465fad7c (matthew    2022-01-20 14:01:55 -0500  521) 
465fad7c (matthew    2022-01-20 14:01:55 -0500  522)             }
465fad7c (matthew    2022-01-20 14:01:55 -0500  523)         }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  524) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  525)         pub fn destructive_print_ppuc_tree(ppuc_tree: &mut super::BinaryHeap<super::super::lease_gen::PPUC>){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  526)             while ppuc_tree.peek() != None{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  527)                 println!("ppuc: {:?}",ppuc_tree.pop().unwrap());
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  528)             }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  529)         }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  530)     }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  531) }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  532) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  533) //Small miscellaneous functions used 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  534) mod helpers {
177a91f6 (matthew    2021-09-25 04:20:29 -0400  535)     pub fn float_min(a: f64, b:f64) -> f64{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  536)         if a.lt(&b){ 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  537)             return a;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  538)         }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  539)         b
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  540)     }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  541) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  542)     pub fn binary_search(vector: &Vec<(u64,u64)>,value:u64) -> Option<(u64,u64)>{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  543)         let mut min = 0;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  544)         let mut max = vector.len() - 1;
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  545) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  546)         while max>=min{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  547)             let guess = (max + min)/2;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  548)             if vector[guess].0==value{ //on transition sample
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  549)                 if guess < vector.len() - 1{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  550)                     return Some(vector[guess+1]);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  551)                 }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  552)                 //transition of last phase
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  553)                 return None;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  554)             }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  555) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  556)             if vector[guess].0 < value{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  557)                 min = guess+1;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  558)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  559)             if vector[guess].0 > value{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  560)                 if guess >0{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  561)                     max = guess-1;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  562)                 }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  563)                 else{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  564)                     return Some(vector[guess])
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  565)                 }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  566)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  567)         }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  568)         assert_eq!(max,min-1);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  569)         if min==vector.len(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  570)             return None;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  571)         }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  572) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  573)         Some(vector[min])
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  574)     }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  575) }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  576) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  577) //Core Algorithms
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  578) pub mod lease_gen {
eff726b1 (matthew    2021-09-09 01:24:16 -0400  579)    
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  580)     use std::collections::BinaryHeap;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  581)     use std::collections::HashMap;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  582)     use core::cmp::Ordering;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  583)     #[derive(Debug,Clone)]
eff726b1 (matthew    2021-09-09 01:24:16 -0400  584)     pub struct BinFreqs{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  585)         pub bin_freqs: HashMap <u64,HashMap<u64,u64>>,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  586)           
eff726b1 (matthew    2021-09-09 01:24:16 -0400  587)     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  588)       #[derive(Debug,Clone)]
eff726b1 (matthew    2021-09-09 01:24:16 -0400  589)     pub struct BinnedRIs{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  590)         pub bin_ri_distribution: HashMap <u64,HashMap<u64,HashMap<u64,u64>>>,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  591)        
eff726b1 (matthew    2021-09-09 01:24:16 -0400  592)     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  593)     
eff726b1 (matthew    2021-09-09 01:24:16 -0400  594)     impl BinFreqs{
8cf770ac (matthew    2021-09-11 00:40:05 -0400  595)         pub fn new(bin_freqs_input: HashMap<u64,HashMap<u64,u64>>) -> Self{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  596)             BinFreqs{
8cf770ac (matthew    2021-09-11 00:40:05 -0400  597)                 bin_freqs:bin_freqs_input,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  598)             } 
eff726b1 (matthew    2021-09-09 01:24:16 -0400  599)         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  600)     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  601) 
eff726b1 (matthew    2021-09-09 01:24:16 -0400  602)     impl BinnedRIs{
8cf770ac (matthew    2021-09-11 00:40:05 -0400  603)         pub fn new(bin_ri_input: HashMap <u64,HashMap<u64,HashMap<u64,u64>>>) -> Self{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  604)             BinnedRIs{
8cf770ac (matthew    2021-09-11 00:40:05 -0400  605)                 bin_ri_distribution:bin_ri_input,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  606)             } 
eff726b1 (matthew    2021-09-09 01:24:16 -0400  607)         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  608)     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  609) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  610)     pub struct RIHists{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  611)         pub ri_hists: HashMap<u64,HashMap<u64,(u64,HashMap<u64,(u64,u64)>)>>,
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  612)     }
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  613) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  614)     impl RIHists {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  615)         pub fn new(ri_hists_input: HashMap<u64,HashMap<u64,(u64,HashMap<u64,(u64,u64)>)>>) -> Self{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  616)             RIHists{
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  617)                 ri_hists: ri_hists_input,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  618)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  619)         }
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  620) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  621)         pub fn get_ref_hist(&self,ref_id: u64) -> &HashMap<u64,(u64,HashMap<u64,(u64,u64)>)>{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  622)             return self.ri_hists.get(&ref_id).unwrap();
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  623)         }
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  624) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  625)         pub fn get_ref_ri_count(&self,ref_id: u64,ri:u64) -> u64 {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  626)             return self.ri_hists.get(&ref_id).unwrap().get(&ri).unwrap().0;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  627)         }
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  628) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  629)         pub fn get_ref_ri_cost(&self,ref_id: u64,ri:u64) -> &HashMap<u64,(u64,u64)> {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  630)             return &self.ri_hists.get(&ref_id).unwrap().get(&ri).unwrap().1;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  631)         }
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  632) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  633)         pub fn get_ref_ri_phase_cost(&self,ref_id: u64, ri:u64, phase: u64) -> (u64,u64) {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  634)             return *self.ri_hists.get(&ref_id).unwrap().get(&ri).unwrap().1.get(&phase).unwrap();
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  635)         }
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  636)     }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  637) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  638)     #[derive(Debug,Copy,Clone)]
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  639)     pub struct PPUC {
177a91f6 (matthew    2021-09-25 04:20:29 -0400  640)         ppuc: f64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  641)         lease: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  642)         old_lease: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  643)         ref_id: u64,
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  644)         new_hits: u64,
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  645)     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  646)     impl PartialOrd for PPUC {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  647)         fn partial_cmp(&self, other: &Self) -> Option<Ordering>{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  648)             self.ppuc.partial_cmp(&other.ppuc)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  649)         }
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  650)     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  651)     impl Ord for PPUC {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  652)         fn cmp(&self, other: &Self) -> Ordering {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  653)             other.ppuc.partial_cmp(&self.ppuc).unwrap()
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  654)         }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  655)     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  656)     impl PartialEq for PPUC {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  657)         fn eq(&self, other: &Self) -> bool{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  658)             other.ppuc.eq(&self.ppuc)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  659)         }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  660)     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  661)     impl Eq for PPUC {}
71b6e8c4 (Ben Reber  2021-07-08 15:44:34 -0400  662) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  663)     pub fn process_sample_head_cost(ri_hists: &mut HashMap<u64,HashMap<u64,(u64,HashMap<u64,(u64,u64)>)>>,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  664)                       phase_id_ref: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  665)                       ri: u64,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  666)                       use_time: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  667)                       next_phase_tuple: (u64,u64)){
f90180c6 (Ben Reber  2021-07-01 13:13:02 -0400  668) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  669)         let phase_id = (phase_id_ref & 0xFF000000)>>24;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  670) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  671)         //increment count
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  672)         let ref_hist = ri_hists.entry(phase_id_ref).or_insert_with(|| HashMap::new());
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  673)         let ri_tuple = ref_hist.entry(ri).or_insert_with(|| (0,HashMap::new()));
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  674)         ri_tuple.0  += 1;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  675) 
20d01f90 (matthew    2021-10-10 19:48:45 -0400  676)          //increment head costs
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  677)         let this_phase_head_cost= std::cmp::min(next_phase_tuple.0 - use_time,ri);
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  678)         let next_phase_head_cost= std::cmp::max(use_time as i64 + ri as i64 - next_phase_tuple.0 as i64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  679)                                                 0) as u64;
20d01f90 (matthew    2021-10-10 19:48:45 -0400  680)        
20d01f90 (matthew    2021-10-10 19:48:45 -0400  681)         
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  682)         ri_tuple.1.entry(phase_id)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  683)             .or_insert_with(|| (0,0)).0 += this_phase_head_cost;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  684) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  685)         if next_phase_head_cost>0 {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  686)             ri_tuple.1.entry(next_phase_tuple.1)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  687)                 .or_insert_with(|| (0,0)).0 += next_phase_head_cost;
f90180c6 (Ben Reber  2021-07-01 13:13:02 -0400  688)         }
f90180c6 (Ben Reber  2021-07-01 13:13:02 -0400  689)     }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400  690) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  691)     pub fn process_sample_tail_cost(ri_hists: &mut HashMap<u64,HashMap<u64,(u64,HashMap<u64,(u64,u64)>)>>,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  692)                       phase_id_ref: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  693)                       ri: u64,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  694)                       use_time: u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  695)                       next_phase_tuple: (u64,u64)){
f29e8786 (Ben Reber  2021-07-08 12:40:26 -0400  696) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  697)         let phase_id = (phase_id_ref & 0xFF000000)>>24;
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  698) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  699)         let ref_hist = ri_hists.entry(phase_id_ref)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  700)             .or_insert_with(|| HashMap::new());
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  701) 
eff726b1 (matthew    2021-09-09 01:24:16 -0400  702)         //this heinous code exists so we can iterate through a HashMap while modifying it
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  703)         let ris: Vec<&u64> = ref_hist.keys().collect();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  704)         let mut ris_keys :Vec<u64> = Vec::new();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  705)         for ri_other in ris{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  706)             ris_keys.push(*ri_other);
fac1336c (Ben Reber  2021-07-09 12:37:16 -0400  707)         }
2cff0195 (Ben Reber  2021-07-09 15:06:38 -0400  708) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  709)         //increment tail costs
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  710)         for ri_other in ris_keys {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  711) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  712)             //no tail cost if the other ri is greater
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  713)             if ri_other >= ri {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  714)                 continue;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  715)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  716)             let count_phase_cost_tuple = ref_hist.entry(ri_other)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  717)                 .or_insert_with(|| (0,HashMap::new()));
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  718) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  719)             let this_phase_tail_cost = std::cmp::min(next_phase_tuple.0 - use_time,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  720)                                                      ri_other);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  721)             let next_phase_tail_cost = std::cmp::max(0,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  722)                                                      use_time as i64 + 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  723)                                                        ri_other as i64 - 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  724)                                                        next_phase_tuple.0 as i64) as u64;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  725) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  726)             count_phase_cost_tuple.1.entry(phase_id)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  727)                 .or_insert_with(|| (0,0)).1 += this_phase_tail_cost;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  728) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  729)             if next_phase_tail_cost > 0 {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  730)                 count_phase_cost_tuple.1.entry(next_phase_tuple.1)
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  731)                     .or_insert_with(|| (0,0)).1 += next_phase_tail_cost;
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400  732)             }
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400  733)         }
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400  734)     }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  735) 
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  736)     fn cshel_phase_ref_cost(sample_rate: u64, phase: u64,ref_id: u64,old_lease: u64,new_lease: u64,ri_hists: &RIHists) -> u64 {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  737)         let mut old_cost = 0;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  738)         let mut new_cost = 0;
614408e5 (matthew    2021-11-10 23:51:03 -0500  739)         //if a set in a phase does not have this reference
614408e5 (matthew    2021-11-10 23:51:03 -0500  740)         if ri_hists.ri_hists.get(&ref_id)==None {
614408e5 (matthew    2021-11-10 23:51:03 -0500  741)             return 0;
614408e5 (matthew    2021-11-10 23:51:03 -0500  742)         }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  743)         let ri_hist = ri_hists.ri_hists.get(&ref_id).unwrap();
2cff0195 (Ben Reber  2021-07-09 15:06:38 -0400  744) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  745)         for (&ri,(_,phase_cost_hashmap)) in ri_hist.iter(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  746)             let (phase_head_cost,phase_tail_cost) = match phase_cost_hashmap.get(&phase) {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  747)                 Some((a,b)) => (*a,*b),
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  748)                 None        => (0,0), 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  749)             };
177a91f6 (matthew    2021-09-25 04:20:29 -0400  750)               if ri <= old_lease {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  751)                 old_cost += phase_head_cost;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  752)             }
177a91f6 (matthew    2021-09-25 04:20:29 -0400  753)             if ri ==old_lease {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  754)                 old_cost += phase_tail_cost;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  755)             }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  756) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  757)             if ri <= new_lease {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  758)                 new_cost += phase_head_cost;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  759)             }
177a91f6 (matthew    2021-09-25 04:20:29 -0400  760)             if ri ==new_lease {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  761)                 new_cost += phase_tail_cost;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  762)             }
09c93cae (matthew    2021-09-29 22:21:41 -0400  763)           
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  764)         }
177a91f6 (matthew    2021-09-25 04:20:29 -0400  765)       
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  766)         (new_cost - old_cost) * sample_rate   
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  767)     }
2cff0195 (Ben Reber  2021-07-09 15:06:38 -0400  768) 
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  769)     fn shel_phase_ref_cost(sample_rate: u64, 
08c868a4 (Ben Reber  2021-07-26 14:05:55 -0400  770)                            phase:      u64,
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  771)                            ref_id:      u64,
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  772)                            old_lease:   u64,
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  773)                            new_lease:   u64,
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  774)                            ri_hists: &RIHists) -> u64 {
614408e5 (matthew    2021-11-10 23:51:03 -0500  775)         //if a set in a phase does not have this reference
614408e5 (matthew    2021-11-10 23:51:03 -0500  776)         if ri_hists.ri_hists.get(&ref_id)==None {
614408e5 (matthew    2021-11-10 23:51:03 -0500  777)             return 0;
614408e5 (matthew    2021-11-10 23:51:03 -0500  778)         }
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  779)         let ref_ri_hist : &HashMap<u64,(u64,HashMap<u64,(u64,u64)>)> = 
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  780)             ri_hists.ri_hists.get(&ref_id).unwrap(); 
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  781)         let ri_hist: Vec<(u64,u64)> = ref_ri_hist.iter().map(|(k,v)|(*k,v.0)).collect();
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  782)         let mut old_cost = 0;
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  783)         let mut new_cost = 0;
3e08d753 (matthew    2021-09-10 20:54:51 -0400  784)         if phase != (ref_id & 0xFF000000) >> 24 {
3e08d753 (matthew    2021-09-10 20:54:51 -0400  785)             return 0;
3e08d753 (matthew    2021-09-10 20:54:51 -0400  786)         }
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  787)         for (ri,count) in ri_hist.iter(){
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  788)             if *ri <= old_lease {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  789)                 old_cost += *count * *ri;
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  790)             }
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  791)             else {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  792)                 old_cost += *count * old_lease;
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  793)             }
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  794) 
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  795)             if *ri <= new_lease {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  796)                 new_cost += *count * *ri;
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  797)             }
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  798)             else {
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  799)                 new_cost += *count * new_lease;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  800)             }
09c93cae (matthew    2021-09-29 22:21:41 -0400  801)             
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  802)         }
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400  803)         (new_cost - old_cost ) * sample_rate
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  804)     }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  805) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400  806)     pub fn get_ppuc(ref_id: u64, 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  807)                 base_lease: u64, 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  808)                 ref_ri_hist: &HashMap<u64,(u64,HashMap<u64,(u64,u64)>)>) -> Vec<PPUC>{
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400  809) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  810)         let ri_hist: Vec<(u64,u64)> = ref_ri_hist.iter().map(|(k,v)|(*k,v.0)).collect();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  811)         let total_count = ri_hist.iter().fold(0,|acc,(_k,v)| acc+v);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  812)         let mut hits = 0;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  813)         let mut head_cost = 0;
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  814) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  815)         let mut lease_hit_table = HashMap::new();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  816)         let mut lease_cost_table = HashMap::new();
2cff0195 (Ben Reber  2021-07-09 15:06:38 -0400  817) 
3e08d753 (matthew    2021-09-10 20:54:51 -0400  818)         //prevent kernel panic for a base lease that doesn't correspond to sampled ri for a reference
3e08d753 (matthew    2021-09-10 20:54:51 -0400  819)         lease_hit_table.insert(base_lease,0);
3e08d753 (matthew    2021-09-10 20:54:51 -0400  820)         lease_cost_table.insert(base_lease,0);
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  821) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  822)         let mut ri_hist_clone = ri_hist.clone();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  823)         ri_hist_clone.sort_by(|a,b| a.0.cmp(&b.0));
3e08d753 (matthew    2021-09-10 20:54:51 -0400  824)         
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  825)         for (ri,count) in ri_hist_clone.iter(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  826)             hits += *count;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  827)             head_cost += *count * *ri ;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  828)             let tail_cost = (total_count - hits) * *ri ;
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  829) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  830)             lease_hit_table.insert(*ri,hits);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  831)             lease_cost_table.insert(*ri,head_cost + tail_cost);
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  832)         }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400  833) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  834)         ri_hist_clone.iter().map(|(k,_v)| k).filter(|k| **k > base_lease).map(
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  835)             |k| PPUC {
177a91f6 (matthew    2021-09-25 04:20:29 -0400  836)                 ppuc:((*lease_hit_table.get(k).unwrap() -*lease_hit_table.get(&base_lease).unwrap()) as f64/
177a91f6 (matthew    2021-09-25 04:20:29 -0400  837)                       (*lease_cost_table.get(k).unwrap()-*lease_cost_table.get(&base_lease).unwrap())as f64),
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  838)                 lease: *k,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  839)                 old_lease: base_lease,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  840)                 ref_id: ref_id, 
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400  841)                 new_hits: *lease_hit_table.get(k).unwrap() - *lease_hit_table.get(&base_lease).unwrap(),
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  842)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  843)         ).collect()
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400  844)     }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  845)     
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  846)     pub fn get_avg_lease(distribution:&BinnedRIs, 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  847)                          addr: &u64, 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  848)                          bin: u64,
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  849)                          lease: u64) -> u64 { 
eff726b1 (matthew    2021-09-09 01:24:16 -0400  850)         let mut total=0;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  851)         for (ri,freq) in distribution.bin_ri_distribution.get(&bin).unwrap().get(&addr).unwrap(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400  852)             if *ri<=lease && *ri>0{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  853)                 total+=ri*freq;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  854)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  855)             else {
eff726b1 (matthew    2021-09-09 01:24:16 -0400  856)                 total+=lease*freq;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  857)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  858)         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  859)         return total;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  860)     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  861) 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  862)     pub fn prl(bin_width : u64,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  863)                 ri_hists : &RIHists,
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  864)                 binned_ris: &BinnedRIs,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  865)                 binned_freqs: &BinFreqs,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  866)                 sample_rate : u64,
eff726b1 (matthew    2021-09-09 01:24:16 -0400  867)                 cache_size : u64,
2f68992c (matthew    2021-10-10 20:30:16 -0400  868)                 discretize: u64,
8cf770ac (matthew    2021-09-11 00:40:05 -0400  869)                 samples_per_phase : &HashMap<u64,u64>,
614408e5 (matthew    2021-11-10 23:51:03 -0500  870)                 verbose: bool,
614408e5 (matthew    2021-11-10 23:51:03 -0500  871)                 debug: bool,
614408e5 (matthew    2021-11-10 23:51:03 -0500  872)                 set_mask : u32)-> Option<(HashMap<u64,u64>,HashMap<u64,(f64,u64)>,HashMap<u64,HashMap<u64,u64>>,u64)>{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  873)         let mut new_lease: PPUC;
177a91f6 (matthew    2021-09-25 04:20:29 -0400  874)         let mut dual_leases : HashMap<u64,(f64,u64)>= HashMap::new(); //{ref_id, (alpha, long_lease)}
eff726b1 (matthew    2021-09-09 01:24:16 -0400  875)         let mut trace_length : u64=0;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  876)         let mut bin_endpoints:Vec<u64>=Vec::new();
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  877)         let mut num_unsuitable:u64;
614408e5 (matthew    2021-11-10 23:51:03 -0500  878)         let mut ppuc_tree = BinaryHeap::new();
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  879)         let mut impact_dict:HashMap<u64,HashMap<u64,f64>>=HashMap::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500  880)         let mut bin_ranks:HashMap<u64,f64>=HashMap::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500  881)         let mut sorted_bins:Vec<(u64,f64)>=Vec::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500  882)         let mut acceptable_ratio:f64;
614408e5 (matthew    2021-11-10 23:51:03 -0500  883)         let mut neg_impact;
614408e5 (matthew    2021-11-10 23:51:03 -0500  884)         let mut lease_hits=HashMap::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500  885)         let mut num_full_bins;
614408e5 (matthew    2021-11-10 23:51:03 -0500  886)         let mut bin_saturation:HashMap<u64,HashMap<u64,f64>>=HashMap::new();
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  887)         let mut leases:HashMap<u64,u64>=HashMap::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500  888) 
614408e5 (matthew    2021-11-10 23:51:03 -0500  889)         let num_sets=set_mask as u64+1;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  890)         let bin_target:u64=bin_width*cache_size/num_sets;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  891)         //threshold for meaningful dual lease
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500  892)         let min_alpha=1.0-(((2<<(discretize-1)) as f64)-1.5 as f64)/(((2<<(discretize-1)) as f64)-1.0 as f64); 
2f68992c (matthew    2021-10-10 20:30:16 -0400  893) 
465fad7c (matthew    2022-01-20 14:01:55 -0500  894)         if verbose {
465fad7c (matthew    2022-01-20 14:01:55 -0500  895)             println!("---------Dump Binned RI Hists------------");
465fad7c (matthew    2022-01-20 14:01:55 -0500  896)              super::io::debug::print_binned_hists(&binned_ris);
465fad7c (matthew    2022-01-20 14:01:55 -0500  897)             println!("---------Dump Reference Frequency per bin---");
465fad7c (matthew    2022-01-20 14:01:55 -0500  898)             println!("{:?}",&binned_freqs);
465fad7c (matthew    2022-01-20 14:01:55 -0500  899)          }
465fad7c (matthew    2022-01-20 14:01:55 -0500  900)         
465fad7c (matthew    2022-01-20 14:01:55 -0500  901) 
8cf770ac (matthew    2021-09-11 00:40:05 -0400  902)         if verbose{
3e08d753 (matthew    2021-09-10 20:54:51 -0400  903)         println!("bin_width:  {}",bin_width);
614408e5 (matthew    2021-11-10 23:51:03 -0500  904)          }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  905)        for key in binned_freqs.bin_freqs.keys(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400  906)             bin_endpoints.push(*key);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  907)        }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  908)        //each bin will have all addresses although freq may be 0
eff726b1 (matthew    2021-09-09 01:24:16 -0400  909)        let mut addrs:Vec<u64>=Vec::new();
eff726b1 (matthew    2021-09-09 01:24:16 -0400  910)        for key in binned_freqs.bin_freqs.get(&0).unwrap().keys(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400  911)             addrs.push(*key);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  912)        }
614408e5 (matthew    2021-11-10 23:51:03 -0500  913)      
614408e5 (matthew    2021-11-10 23:51:03 -0500  914) 
614408e5 (matthew    2021-11-10 23:51:03 -0500  915)         for endpoint in bin_endpoints.iter(){
614408e5 (matthew    2021-11-10 23:51:03 -0500  916)             for set in 0..num_sets{
614408e5 (matthew    2021-11-10 23:51:03 -0500  917)             bin_saturation.entry(*endpoint).or_insert(HashMap::new()).entry(set).or_insert(0.0);
614408e5 (matthew    2021-11-10 23:51:03 -0500  918)             }
614408e5 (matthew    2021-11-10 23:51:03 -0500  919)         }
126c4133 (matthew    2021-09-09 04:15:05 -0400  920)         //make all references have lease of 1
126c4133 (matthew    2021-09-09 04:15:05 -0400  921)         for addr in addrs{
614408e5 (matthew    2021-11-10 23:51:03 -0500  922)             leases.insert(addr&0x00FFFFFF,1);
36911289 (matthew    2021-09-11 02:37:49 -0400  923)            // update saturation to take into account each reference having a lease of 1
89d73b4e (matthew    2021-11-17 18:43:03 -0500  924)             for (bin,_sat) in bin_saturation.clone(){
614408e5 (matthew    2021-11-10 23:51:03 -0500  925)                 for set in 0..num_sets{
89d73b4e (matthew    2021-11-17 18:43:03 -0500  926)                     if  binned_ris.bin_ri_distribution.get(&bin).unwrap().contains_key(&addr){
89d73b4e (matthew    2021-11-17 18:43:03 -0500  927)                         let  old_avg_lease=get_avg_lease(binned_ris,&addr,bin,0);
89d73b4e (matthew    2021-11-17 18:43:03 -0500  928)                         let avg_lease =get_avg_lease(binned_ris,&addr,bin,1);
614408e5 (matthew    2021-11-10 23:51:03 -0500  929)                         let impact= (avg_lease as f64-old_avg_lease as f64)*&(sample_rate as f64);
89d73b4e (matthew    2021-11-17 18:43:03 -0500  930)                         let bin_saturation_set=bin_saturation.get_mut(&bin).unwrap();
89d73b4e (matthew    2021-11-17 18:43:03 -0500  931)                         bin_saturation_set.insert(set,bin_saturation_set.get(&set).unwrap()+impact);
614408e5 (matthew    2021-11-10 23:51:03 -0500  932)                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500  933)                      //init impact dict for later
89d73b4e (matthew    2021-11-17 18:43:03 -0500  934)                         impact_dict.entry(bin).or_insert(HashMap::new()).entry(set).or_insert(0.0);
126c4133 (matthew    2021-09-09 04:15:05 -0400  935)                 }
126c4133 (matthew    2021-09-09 04:15:05 -0400  936)             }
126c4133 (matthew    2021-09-09 04:15:05 -0400  937)        }
126c4133 (matthew    2021-09-09 04:15:05 -0400  938)         
614408e5 (matthew    2021-11-10 23:51:03 -0500  939)        
eff726b1 (matthew    2021-09-09 01:24:16 -0400  940)         for (_phase,&num) in samples_per_phase.iter(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400  941)             trace_length += num * sample_rate;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  942)         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  943)        
eff726b1 (matthew    2021-09-09 01:24:16 -0400  944)         for (&ref_id, ri_hist) in ri_hists.ri_hists.iter(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400  945)             let ppuc_vec = get_ppuc(ref_id,0,ri_hist);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  946)             for ppuc in ppuc_vec.iter(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400  947)                 ppuc_tree.push(*ppuc);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  948)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  949)         }
36911289 (matthew    2021-09-11 02:37:49 -0400  950)        // get lease hits assuming a base lease of 0
36911289 (matthew    2021-09-11 02:37:49 -0400  951)         for _r in ppuc_tree.clone(){
36911289 (matthew    2021-09-11 02:37:49 -0400  952)             let lease= ppuc_tree.pop().unwrap();
465fad7c (matthew    2022-01-20 14:01:55 -0500  953)             lease_hits.entry(lease.ref_id).or_insert(HashMap::new()).entry(lease.lease).or_insert(lease.new_hits);
36911289 (matthew    2021-09-11 02:37:49 -0400  954)       }
36911289 (matthew    2021-09-11 02:37:49 -0400  955)         //reinitallize ppuc tree, assuming a base lease of 1
36911289 (matthew    2021-09-11 02:37:49 -0400  956)         for (&ref_id, ri_hist) in ri_hists.ri_hists.iter(){
36911289 (matthew    2021-09-11 02:37:49 -0400  957)             let ppuc_vec = get_ppuc(ref_id,1,ri_hist);
36911289 (matthew    2021-09-11 02:37:49 -0400  958)             for ppuc in ppuc_vec.iter(){
36911289 (matthew    2021-09-11 02:37:49 -0400  959)                 ppuc_tree.push(*ppuc);
36911289 (matthew    2021-09-11 02:37:49 -0400  960)             }
36911289 (matthew    2021-09-11 02:37:49 -0400  961)         }
3e08d753 (matthew    2021-09-10 20:54:51 -0400  962)         
eff726b1 (matthew    2021-09-09 01:24:16 -0400  963)     
eff726b1 (matthew    2021-09-09 01:24:16 -0400  964)         loop {
eff726b1 (matthew    2021-09-09 01:24:16 -0400  965)              new_lease = match ppuc_tree.pop(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400  966)                 Some(i) => i,
092a6ba0 (matthew    2021-09-09 05:39:51 -0400  967)                 None => return Some((leases,dual_leases, lease_hits,trace_length)),
eff726b1 (matthew    2021-09-09 01:24:16 -0400  968)             };
36911289 (matthew    2021-09-11 02:37:49 -0400  969)            
36911289 (matthew    2021-09-11 02:37:49 -0400  970)              //continue to pop until we have a ppuc with the right base_lease
614408e5 (matthew    2021-11-10 23:51:03 -0500  971)             if new_lease.old_lease != *leases.get(&(new_lease.ref_id&0xFFFFFFFF)).unwrap(){
126c4133 (matthew    2021-09-09 04:15:05 -0400  972)                 continue;
126c4133 (matthew    2021-09-09 04:15:05 -0400  973)             }
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  974)             //won't assign a reference to a reference that has recieved a dual lease
614408e5 (matthew    2021-11-10 23:51:03 -0500  975)             if dual_leases.contains_key(&(new_lease.ref_id&0xFFFFFFFF)){
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  976)                 continue;
3dcbac4c (matthew    2021-09-12 18:06:29 -0400  977)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  978)             neg_impact=false;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  979)             num_unsuitable=0;
eff726b1 (matthew    2021-09-09 01:24:16 -0400  980)             let addr= new_lease.ref_id;
614408e5 (matthew    2021-11-10 23:51:03 -0500  981)            for (bin,bin_sat_set) in &bin_saturation{
614408e5 (matthew    2021-11-10 23:51:03 -0500  982)             for (set,_sat) in bin_sat_set{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  983)                 let mut impact:f64 =0.0;
614408e5 (matthew    2021-11-10 23:51:03 -0500  984)                 let set_addr=(addr&0xFFFFFFFF)|(set<<32);
614408e5 (matthew    2021-11-10 23:51:03 -0500  985)                 if  binned_ris.bin_ri_distribution.get(&bin).unwrap().contains_key(&set_addr){
614408e5 (matthew    2021-11-10 23:51:03 -0500  986)                     let  old_avg_lease=get_avg_lease(binned_ris,&set_addr,*bin,*leases.get(&(addr&0xFFFFFFFF)).unwrap());
614408e5 (matthew    2021-11-10 23:51:03 -0500  987)                     let avg_lease =get_avg_lease(binned_ris,&set_addr,*bin,new_lease.lease);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  988)                     impact= (avg_lease as f64-old_avg_lease as f64)*&(sample_rate as f64);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  989)                     //don't assign leases that decrease bin saturation
eff726b1 (matthew    2021-09-09 01:24:16 -0400  990)                     neg_impact = if impact>=0.0 {false} else {true};
614408e5 (matthew    2021-11-10 23:51:03 -0500  991)                     impact_dict.get_mut(&bin).unwrap().insert(*set,impact as f64);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  992)                 }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  993)                 else{
614408e5 (matthew    2021-11-10 23:51:03 -0500  994)                     impact_dict.get_mut(&bin).unwrap().insert(*set,0 as f64);
eff726b1 (matthew    2021-09-09 01:24:16 -0400  995)                 }
eff726b1 (matthew    2021-09-09 01:24:16 -0400  996) 
614408e5 (matthew    2021-11-10 23:51:03 -0500  997)                 if (bin_saturation.get(&bin).unwrap().get(&set).unwrap()+impact)>bin_target as f64{
eff726b1 (matthew    2021-09-09 01:24:16 -0400  998)                    
eff726b1 (matthew    2021-09-09 01:24:16 -0400  999)                     num_unsuitable+=1;
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1000)                 }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1001)             }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1002)         }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1003)             for (bin,sat_set) in &bin_saturation.clone(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1004)                 for (set,sat) in sat_set{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1005)                     if verbose && debug {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1006)                         println!("bin: {} set: {} current capacity: {:.7} impact: {:.7}", bin/bin_width, set, sat/bin_width as f64,impact_dict.get(bin).unwrap().get(set).unwrap()/bin_width as f64); 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1007)                     }
3dcbac4c (matthew    2021-09-12 18:06:29 -0400 1008)                 }
3dcbac4c (matthew    2021-09-12 18:06:29 -0400 1009)              }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1010)              if verbose{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1011)                 println!("addr:{:x} ri:{:x}",addr&0xFFFFFFFF,new_lease.lease);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1012)              }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1013)             
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1014)             //skip lease, if it makes it worse
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1015)            
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1016)             if neg_impact{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1017)                 if verbose{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1018)                     println!("lease value would be negative");
614408e5 (matthew    2021-11-10 23:51:03 -0500 1019)                 }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1020)                 continue;
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1021)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1022)             if num_unsuitable<1{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1023)                 leases.insert(addr&0xFFFFFFFF,new_lease.lease);
36911289 (matthew    2021-09-11 02:37:49 -0400 1024)                  //push new ppucs
36911289 (matthew    2021-09-11 02:37:49 -0400 1025)                 let ppuc_vec = get_ppuc(new_lease.ref_id,
36911289 (matthew    2021-09-11 02:37:49 -0400 1026)                                         new_lease.lease,
36911289 (matthew    2021-09-11 02:37:49 -0400 1027)                                         ri_hists.ri_hists.get(&new_lease.ref_id).unwrap());
36911289 (matthew    2021-09-11 02:37:49 -0400 1028) 
36911289 (matthew    2021-09-11 02:37:49 -0400 1029)                 for ppuc in ppuc_vec.iter(){
36911289 (matthew    2021-09-11 02:37:49 -0400 1030)                     ppuc_tree.push(*ppuc);
36911289 (matthew    2021-09-11 02:37:49 -0400 1031)                 }
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1032)                  let mut print_string:String=String::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1033)                 for (bin,sat_set) in &bin_saturation.clone(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1034)                     for (set,sat) in sat_set{ 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1035)                         let set_addr=(addr&0xFFFFFFFF)|(set<<32);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1036)                      if  binned_ris.bin_ri_distribution.get(bin).unwrap().contains_key(&set_addr){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1037)                         bin_saturation.get_mut(bin).unwrap().insert(*set,sat+impact_dict.get(bin).unwrap().get(set).unwrap());
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1038)                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1039)                     print_string=format!("{:} {1:.7}",print_string,&(bin_saturation.get(bin).unwrap().get(set).unwrap()/bin_width as f64));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1040)                    }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1041)                 }
8cf770ac (matthew    2021-09-11 00:40:05 -0400 1042)                 if verbose{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1043)                   println!("assigning lease: {:x} to reference {:x}",new_lease.lease, addr);
3dcbac4c (matthew    2021-09-12 18:06:29 -0400 1044)                  println!("Average cache occupancy per bin: [{}]",print_string);
8cf770ac (matthew    2021-09-11 00:40:05 -0400 1045)              }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1046)             }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1047)             else {
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1048)                 num_full_bins=0;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1049)                 let mut alpha=1.0;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1050)                 for (bin,sat_set) in &bin_saturation{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1051)                     for (set,sat) in sat_set{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1052)                         if sat>=&(bin_target as f64){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1053)                             num_full_bins+=1
614408e5 (matthew    2021-11-10 23:51:03 -0500 1054)                         }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1055)                         let new_capacity=sat+impact_dict.get(bin).unwrap().get(set).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1056)                         
614408e5 (matthew    2021-11-10 23:51:03 -0500 1057)                         if&new_capacity>=&(bin_target as f64){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1058)                             if *impact_dict.get(bin).unwrap().get(set).unwrap()!=0.0{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1059)                                 //get minimum set alpha for bin
614408e5 (matthew    2021-11-10 23:51:03 -0500 1060)                                 let set_alpha = ((bin_target as f64) -sat)/ *impact_dict.get(bin).unwrap().get(set).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1061)                                 if set_alpha<alpha {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1062)                                     alpha=set_alpha;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1063)                                 }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1064)                             }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1065)                           
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1066)                         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1067)                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1068)                       bin_ranks.insert(*bin,alpha);
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1069)                 }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1070)                 for (num,key_val_pair) in bin_ranks.iter().enumerate(){
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1071)                     if sorted_bins.get_mut(num)==None{
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1072)                         sorted_bins.push((*key_val_pair.0,*key_val_pair.1));
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1073)                     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1074)                     else{
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1075)                         sorted_bins[num]=(*key_val_pair.0,*key_val_pair.1);
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1076)                     }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1077)                 }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1078)                 sorted_bins.sort_by(|a,b| a.1.partial_cmp(&b.1).unwrap());
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1079)                 acceptable_ratio= if num_full_bins==0 {sorted_bins[0].1} else {0.0};
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1080)                
2f68992c (matthew    2021-10-10 20:30:16 -0400 1081)                 if acceptable_ratio>min_alpha{
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1082)                     dual_leases.insert(addr,(acceptable_ratio as f64,new_lease.lease));
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1083)                         let mut print_string:String=String::new();
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1084) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1085)                     for (bin,sat_set) in &bin_saturation.clone(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1086)                         for (set,sat) in sat_set{ 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1087)                             let set_addr=(addr&0xFFFFFFFF)|(set<<32);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1088)                             if  binned_ris.bin_ri_distribution.get(bin).unwrap().contains_key(&set_addr){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1089)                               bin_saturation.get_mut(bin).unwrap().insert(*set,sat+impact_dict.get(bin).unwrap().get(set).unwrap()*acceptable_ratio);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1090)                              }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1091)                             print_string=format!("{:} {1:.7}",print_string,&(bin_saturation.get(bin).unwrap().get(set).unwrap()/bin_width as f64));
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1092)                         }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1093)                     }
8cf770ac (matthew    2021-09-11 00:40:05 -0400 1094)                     if verbose{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1095)                             println!("Assigning dual lease {} to address {} with percentage: {}",new_lease.lease,addr,acceptable_ratio);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1096)                             println!("Average cache occupancy per bin: [{}]",print_string);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1097)                         }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1098)                     }
8cf770ac (matthew    2021-09-11 00:40:05 -0400 1099)                 }
eff726b1 (matthew    2021-09-09 01:24:16 -0400 1100)             }
126c4133 (matthew    2021-09-09 04:15:05 -0400 1101) 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1102)     }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1103) 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1104)     pub fn get_num_leases_per_phase(leases: &HashMap<u64,u64>) -> HashMap<u64,u64> {
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1105)         let mut references_per_phase: HashMap<u64,u64> = HashMap::new();
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1106)         for (phase_id_x_reference, _lease) in leases.iter(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1107)             let phase_id = (phase_id_x_reference&0xFF000000)>>24;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1108)             references_per_phase.entry(phase_id)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1109)                 .and_modify(|e| {*e += 1})
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1110)                 .or_insert(1);
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1111)         }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1112)         return references_per_phase;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1113)     }
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400 1114) 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1115)     pub fn prune_leases_to_fit_llt(leases: &mut HashMap<u64,u64>,
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1116)                                    dual_leases: &mut HashMap<u64,(f64,u64)>,
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1117)                                    ri_hists: &RIHists,
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1118)                                    llt_size: u64){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1119)         let references_per_phase: HashMap<u64,u64> = get_num_leases_per_phase(&leases); 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1120)         for (_phase_id,lease_count) in references_per_phase.iter(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1121)             if *lease_count > llt_size {
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1122)                 let mut importance_per_reference: HashMap<u64,u64> = HashMap::new();
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1123)                 for (reference, _lease) in leases.iter(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1124)                     let ri_hist = ri_hists.get_ref_hist(*reference); 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1125)                     let mut count = 0;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1126)                     //need to sum over this 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1127)                     for (_ri,count_cost_tuple) in ri_hist{
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1128)                         count += count_cost_tuple.0;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1129)                     }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1130)                     importance_per_reference.entry(*reference)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1131)                             .or_insert(count);
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1132)                     
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1133)                 }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1134)                 let mut importance_vec: Vec<_> = importance_per_reference.iter().collect();
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1135)                 importance_vec.sort_by(|a, b| a.1.cmp(b.1).reverse());
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1136)                 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1137)                 for i in llt_size..importance_vec.len() as u64{
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1138)                     //remove all leases that are not important
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1139)                     leases.remove(importance_vec[i as usize].0);
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1140)                     dual_leases.remove(importance_vec[i as usize].0);
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1141)                 }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1142)             }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1143)         } 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1144)     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1145) 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1146)     //Output:
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1147)     //leases: Hashmap<u64,u64>
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1148)     //dual_leases: HashMap<u64, (f64, u64)>
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1149)     //lease_hits: HashMap<u64, HashMap<u64,u64>>
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1150)     //trace_length: u64
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400 1151)     pub fn shel_cshel(cshel: bool,
2e461a57 (Ben Reber  2021-07-15 16:54:03 -0400 1152)                   ri_hists : &RIHists, 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1153)                   cache_size : u64, 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1154)                   sample_rate : u64, 
8cf770ac (matthew    2021-09-11 00:40:05 -0400 1155)                   samples_per_phase : &HashMap<u64,u64>,
2f68992c (matthew    2021-10-10 20:30:16 -0400 1156)                   discretize : u64,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1157)                   verbose: bool,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1158)                   debug: bool,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1159)                   set_mask: u32) -> Option<(HashMap<u64,u64>,HashMap<u64,(f64,u64)>,HashMap<u64,HashMap<u64,u64>>,u64)> {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1160) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1161)         let mut new_lease: PPUC;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1162)         let mut cost_per_phase:HashMap<u64,HashMap<u64,u64>>=HashMap::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1163)         let mut budget_per_phase:HashMap<u64,u64>=HashMap::new();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1164)         let mut leases = HashMap::new(); //{ri, lease}
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1165)         let mut dual_leases : HashMap<u64,(f64,u64)>= HashMap::new(); //{ref_id, (alpha, long_lease)}
2d605402 (Ben Reber  2021-07-22 11:39:09 -0400 1166)         let mut trace_length : u64 = 0;
092a6ba0 (matthew    2021-09-09 05:39:51 -0400 1167)         let mut lease_hits=HashMap::new();
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1168)         let mut dual_lease_phases :Vec<u64>=Vec::new();
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1169)         //{phase,(cost with alpha, cost if alpha was 1, ref ID)}
09c93cae (matthew    2021-09-29 22:21:41 -0400 1170)         let mut past_lease_values :HashMap<u64,(u64,u64)>=HashMap::new();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1171)         let mut last_lease_cost: HashMap<u64,HashMap<u64,(u64,u64,u64)>>=HashMap::new();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1172)         
614408e5 (matthew    2021-11-10 23:51:03 -0500 1173)         let num_sets=set_mask as u64+1;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1174)         let phase_ids: Vec<&u64> = samples_per_phase.keys().collect();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1175)         //since we can't run CSHEL without also running SHEL, don't output RI history twice
614408e5 (matthew    2021-11-10 23:51:03 -0500 1176)         if !cshel {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1177)             if verbose {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1178)             println!("---------Dump RI Hists------------");
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1179)             super::io::debug::print_ri_hists(&ri_hists);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1180)             println!("---------Dump Samples Per Phase---");
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1181)             println!("{:?}",&samples_per_phase);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1182)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1183)         }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1184)         
614408e5 (matthew    2021-11-10 23:51:03 -0500 1185)         
2f68992c (matthew    2021-10-10 20:30:16 -0400 1186)         let min_alpha:f64=1.0-(((2<<(discretize-1)) as f64)-1.5 as f64)/(((2<<(discretize-1)) as f64)-1.0 as f64); //threshold for meaningful dual lease
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1187)         //initialize ppucs
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1188)         let mut ppuc_tree = BinaryHeap::new();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1189) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1190)         for (&ref_id, ri_hist) in ri_hists.ri_hists.iter(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1191)             let ppuc_vec = get_ppuc(ref_id,0,ri_hist);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1192)             for ppuc in ppuc_vec.iter(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1193)                 ppuc_tree.push(*ppuc);
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1194)             }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1195)         }
465fad7c (matthew    2022-01-20 14:01:55 -0500 1196) 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1197)         // get lease hits assuming a base lease of 0
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1198)         for _r in ppuc_tree.clone(){
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1199)             let lease= ppuc_tree.pop().unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1200)             //sum hits for reference over all sets
465fad7c (matthew    2022-01-20 14:01:55 -0500 1201)             *lease_hits.entry(lease.ref_id).or_insert(HashMap::new()).entry(lease.lease).or_insert(0)+=lease.new_hits;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1202) 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1203)         }
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1204)         //reinitallize ppuc tree, assuming a base lease of 1
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1205)         for (&ref_id, ri_hist) in ri_hists.ri_hists.iter(){
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1206)             let ppuc_vec = get_ppuc(ref_id,1,ri_hist);
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1207)             for ppuc in ppuc_vec.iter(){
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1208)                 ppuc_tree.push(*ppuc);
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1209)             }
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1210)         }
fac1336c (Ben Reber  2021-07-09 12:37:16 -0400 1211) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1212)         //initialize cost + budget
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1213)         for (&phase,&num) in samples_per_phase.iter(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1214)              budget_per_phase.entry(phase).or_insert(num * cache_size / num_sets * sample_rate);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1215)              trace_length += num * sample_rate;
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1216)         }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1217) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1218)         if verbose{
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1219)             println!("
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1220)             ---------------------
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1221)             Initial budget per phase: 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1222)             {:?} 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1223)             ---------------------",
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1224)             budget_per_phase);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1225)         }
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1226)         //initialize leases to a default value of 1
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1227)         for (&ref_id, _ ) in ri_hists.ri_hists.iter(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1228)             leases.insert(ref_id&0xFFFFFFFF,1);
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1229)             let phase=(ref_id&0xFF000000)>>24;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1230)             let phase_id_ref=ref_id&0xFFFFFFFF;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1231)             // get cost of assigning a lease of 1 for each set
614408e5 (matthew    2021-11-10 23:51:03 -0500 1232)             for set in 0..num_sets{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1233)                 let set_phase_id_ref=phase_id_ref|(set<<32);
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1234)                 let new_cost = match cshel{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1235)                           true => cshel_phase_ref_cost(sample_rate,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1236)                                                             phase,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1237)                                                             set_phase_id_ref,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1238)                                                             0,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1239)                                                             1,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1240)                                                             &ri_hists),
614408e5 (matthew    2021-11-10 23:51:03 -0500 1241)                           false => shel_phase_ref_cost(sample_rate,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1242)                                                             phase,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1243)                                                             set_phase_id_ref,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1244)                                                             0,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1245)                                                             1,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1246)                                                             &ri_hists),
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1247)                 };
89d73b4e (matthew    2021-11-17 18:43:03 -0500 1248)                 *cost_per_phase.entry(phase).or_insert(HashMap::new()).entry(set).or_insert(0)+=new_cost;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1249)             }
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1250)             
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1251)         }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1252)         if verbose {
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1253)             println!("costs per phase{:?}",cost_per_phase);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1254)         }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1255) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1256)         loop {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1257)             new_lease = match ppuc_tree.pop(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1258)                 //TERMINATION CONDITION 1
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1259)                 Some(i) => i,
092a6ba0 (matthew    2021-09-09 05:39:51 -0400 1260)                 None => return Some((leases,dual_leases,lease_hits,trace_length)),
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1261)             };
614408e5 (matthew    2021-11-10 23:51:03 -0500 1262)             let phase=(new_lease.ref_id&0xFFFFFFFF)>>24;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1263)             let ref_id=new_lease.ref_id&0xFFFFFFFF;
3e08d753 (matthew    2021-09-10 20:54:51 -0400 1264)            
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1265)             //continue to pop until we have a ppuc with the right base_lease
614408e5 (matthew    2021-11-10 23:51:03 -0500 1266)             if new_lease.old_lease != *leases.get(&ref_id).unwrap(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1267)                 continue;
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1268)             }
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1269)             
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1270)             let mut set_full=false;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1271)             for set in 0..num_sets{
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1272)                 if cost_per_phase.get(&phase).unwrap().get(&set).unwrap()==budget_per_phase.get(&phase).unwrap(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1273)                     set_full=true;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1274)                     break;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1275)                 }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1276)             }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1277)             //if any set in phase is full, skip
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1278)             if set_full{
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1279)                 continue;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1280)             }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1281)             //if we've already assigned dual leases to all phases, end
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1282)             if dual_lease_phases.len()==cost_per_phase.len(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1283)                 //TERMINATION CONDITION 2
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1284)                 return Some((leases,dual_leases,lease_hits,trace_length)) ;
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1285)             }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1286)             //if we've already assigned a dual lease for the phase
614408e5 (matthew    2021-11-10 23:51:03 -0500 1287)             if dual_lease_phases.contains(&phase){
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1288)                 continue;
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1289)             }
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1290) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1291)             let old_lease = *leases.get(&ref_id).unwrap();
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1292)             //check for capacity
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1293)             let mut acceptable_lease = true;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1294)             let mut new_phase_ref_cost :HashMap<u64,HashMap<u64,u64>>=HashMap::new(); 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1295)             for (&phase,current_cost) in cost_per_phase.iter(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1296)                 //get cost of assigning a lease of 1 for each set
614408e5 (matthew    2021-11-10 23:51:03 -0500 1297)                 for set in 0..num_sets{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1298)                     let set_phase_id_ref=ref_id|(set<<32);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1299)                     let new_cost = match cshel{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1300)                         true => cshel_phase_ref_cost(sample_rate,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1301)                                                           phase,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1302)                                                           set_phase_id_ref,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1303)                                                           old_lease,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1304)                                                           new_lease.lease,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1305)                                                           &ri_hists),
614408e5 (matthew    2021-11-10 23:51:03 -0500 1306)                         false => shel_phase_ref_cost(sample_rate,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1307)                                                           phase,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1308)                                                           set_phase_id_ref,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1309)                                                           old_lease,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1310)                                                           new_lease.lease,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1311)                                                           &ri_hists),
614408e5 (matthew    2021-11-10 23:51:03 -0500 1312)                     };
614408e5 (matthew    2021-11-10 23:51:03 -0500 1313)                   
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1314)                     new_phase_ref_cost.entry(phase).or_insert(HashMap::new()).entry(set).or_insert(new_cost); 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1315)                     if (new_cost + current_cost.get(&set).unwrap()) > *budget_per_phase.get(&phase).unwrap() {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1316)                         acceptable_lease = false;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1317)                     }
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400 1318)                 }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1319)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1320)             if verbose & debug {
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1321)                 println!("\nDebug: budgets per phase {:?}",&budget_per_phase);
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1322)                 println!("Debug: Current cost budgets {:?}",&cost_per_phase);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1323)                 println!("Debug: NEW_PHASE_REF_COST {:?}",&new_phase_ref_cost);
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1324)                
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1325)             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1326)             if acceptable_lease {
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400 1327)                 //update cache use
614408e5 (matthew    2021-11-10 23:51:03 -0500 1328)                 for (phase,phase_set_costs) in cost_per_phase.iter_mut() {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1329)                     for (set,set_costs) in phase_set_costs.iter_mut(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1330)                             *set_costs+=new_phase_ref_cost.get(phase).unwrap().get(set).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1331)                     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1332)                 }
09c93cae (matthew    2021-09-29 22:21:41 -0400 1333)                 let phase=(new_lease.ref_id & 0xFF000000)>>24;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1334)                 //store lease value we assign to the reference and 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1335)                 //the value of the previously assigned lease for that reference
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1336)                 past_lease_values.insert(new_lease.ref_id&0xFFFFFFFF,
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1337)                                          (new_lease.lease,*leases.get(&(&new_lease.ref_id&0xFFFFFFFF))
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1338)                                           .unwrap()));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1339)                 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1340)                 if last_lease_cost.get_mut(&phase)==None{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1341)                     last_lease_cost.insert(phase,HashMap::new());
614408e5 (matthew    2021-11-10 23:51:03 -0500 1342)                 }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1343)                 for set in 0..num_sets{
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1344)                     last_lease_cost.get_mut(&phase).unwrap().insert(set,
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1345)                                                                     (*new_phase_ref_cost.get(&phase)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1346)                                                                                         .unwrap()
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1347)                                                                                         .get(&set)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1348)                                                                                         .unwrap(),
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1349)                                                                     *new_phase_ref_cost.get(&phase)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1350)                                                                                         .unwrap()
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1351)                                                                                         .get(&set)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1352)                                                                                         .unwrap(),
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1353)                                                                     ref_id&0xFFFFFFFF));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1354)                 }  
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1355)                 //update leases
614408e5 (matthew    2021-11-10 23:51:03 -0500 1356)                 leases.insert(new_lease.ref_id&0xFFFFFFFF,new_lease.lease);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1357)                 //push new ppucs
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1358)                 let ppuc_vec = get_ppuc(new_lease.ref_id,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1359)                                         new_lease.lease,
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1360)                                         ri_hists.ri_hists.get(&new_lease.ref_id).unwrap());
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1361) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1362)                 for ppuc in ppuc_vec.iter(){
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1363)                     ppuc_tree.push(*ppuc);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1364)                 }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1365)                 if verbose {
092a6ba0 (matthew    2021-09-09 05:39:51 -0400 1366)                     println!("Assigned lease {:x} to reference ({},{:x}).", 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1367)                              new_lease.lease, (new_lease.ref_id & 0xFF000000) >> 24, 
092a6ba0 (matthew    2021-09-09 05:39:51 -0400 1368)                              new_lease.ref_id & 0x00FFFFFF);
4377dbdd (Ben Reber  2021-07-13 11:14:09 -0400 1369)                 }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1370)             }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1371) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1372)             else {
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1373)                 //unacceptable lease, must assign a dual lease
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1374)                 let mut alpha = 1.0;
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1375)                 let mut current_phase_alpha = 1.0;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1376)                 for (&phase,phase_set_current_cost) in cost_per_phase.iter(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1377)                      let set_budget=*budget_per_phase.get(&phase).unwrap();
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1378)                      for(&set,&current_set_cost) in phase_set_current_cost.iter(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1379)                         let &set_phase_ref_cost   = new_phase_ref_cost.get(&phase).unwrap().get(&set).unwrap(); 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1380)                         if set_phase_ref_cost > 0 {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1381)                             if set_budget< current_set_cost{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1382)                                 println!("
614408e5 (matthew    2021-11-10 23:51:03 -0500 1383)                                 ERROR: current cost exceeds budget
614408e5 (matthew    2021-11-10 23:51:03 -0500 1384)                                 *budget_per_phase.get(&phase)=.unwrap():  {}
614408e5 (matthew    2021-11-10 23:51:03 -0500 1385)                                 currenc_cost:                            {}
614408e5 (matthew    2021-11-10 23:51:03 -0500 1386)                                 ",
614408e5 (matthew    2021-11-10 23:51:03 -0500 1387)                                 set_budget,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1388)                                 current_set_cost
614408e5 (matthew    2021-11-10 23:51:03 -0500 1389)                                 );
614408e5 (matthew    2021-11-10 23:51:03 -0500 1390)                                 panic!();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1391)                             }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1392) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1393)                             let remaining_budget = set_budget - current_set_cost; 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1394)                             //get the best alpha for any set  (ignoring other phases) that we want for the current reference
614408e5 (matthew    2021-11-10 23:51:03 -0500 1395)                             if phase==(new_lease.ref_id&0xFF000000)>>24 {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1396)                                 current_phase_alpha=super::helpers::float_min(current_phase_alpha,remaining_budget as f64/ 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1397)                                                                                                    set_phase_ref_cost as f64);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1398)                             }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1399)                             alpha = super::helpers::float_min(alpha, 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1400)                                                               remaining_budget as f64 / 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1401)                                                                 set_phase_ref_cost as f64);
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1402)                         }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1403)                     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1404) 
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1405)                 }
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1406)                 //if the alpha we wish to assign would result in 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1407)                 //a long lease that is never used because the short lease 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1408)                 //probabiliy will be 1 after descretizing, don't assign dual lease.
2f68992c (matthew    2021-10-10 20:30:16 -0400 1409)                 if current_phase_alpha<min_alpha{
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1410)                      println!("Assigning lease {:x} with percentage {} to reference ({},{:x}) would not be meaningful.", 
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1411)                                  new_lease.lease,current_phase_alpha,(new_lease.ref_id & 0xFF000000) >> 24, 
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1412)                                  new_lease.ref_id & 0x00FFFFFF);
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1413)                     continue;
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1414)                 }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1415)                
2f68992c (matthew    2021-10-10 20:30:16 -0400 1416)                 if alpha > min_alpha{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1417)                      //update cache use
614408e5 (matthew    2021-11-10 23:51:03 -0500 1418)                     for (phase,phase_set_costs) in cost_per_phase.iter_mut() {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1419)                         let mut set_budget=*budget_per_phase.get(phase).unwrap();
614408e5 (matthew    2021-11-10 23:51:03 -0500 1420)                         for (set,set_costs) in phase_set_costs.iter_mut(){
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1421)                             *set_costs+=(*new_phase_ref_cost.get(phase)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1422)                                                                 .unwrap()
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1423)                                                                 .get(set)
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1424)                                                                 .unwrap() as f64 *alpha).round() as u64;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1425)                             //fix floating point precision error leading 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1426)                             //to "overallocation" or underallocation
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1427)                             if set_costs>&mut set_budget{
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1428)                                 *set_costs=set_budget;
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1429)                             }
576c35c6 (Ben Reber  2021-07-22 12:15:35 -0400 1430)                         }
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1431)                     }
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1432)                 }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1433)                 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1434)                 if cshel{
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1435)                     //if there's no alpha that would assign a meaningful dual lease 
0fc03336 (jammin-ben 2023-02-27 14:38:26 -0500 1436)                     //that wouldn't put other phases over budget
2f68992c (matthew    2021-10-10 20:30:16 -0400 1437)                     if alpha <=min_alpha{
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1438)                         let mut new_costs=HashMap::new();
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1439)                         let mut new_alpha=HashMap::new();
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1440)                         let mut adjust_lease=true;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1441)                         let mut phase_alpha=1.0;
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1442)                         for phase in &phase_ids{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1443)                             for set in 0..num_sets{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1444)                              let set_phase_ref_cost   = new_phase_ref_cost.get(&phase).unwrap().get(&set).unwrap(); 
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1445)                              //if the phase would be effected by the lease assignment
614408e5 (matthew    2021-11-10 23:51:03 -0500 1446)                                 if set_phase_ref_cost > &0 {
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1447)                                      //get phases that would be over budgeted by assigning the current lease.
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1448)                                      //then subtract the cost of their prior dual lease (which may be, due to the default, a non-dual lease)
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1449)                                     //and then add the spillover cost from the new leases
614408e5 (matthew    2021-11-10 23:51:03 -0500 1450)                                     let past_cost_actual=if last_lease_cost.get(&phase)==None {0 } else if last_lease_cost.get(&phase).unwrap().get(&set)==None{0}
614408e5 (matthew    2021-11-10 23:51:03 -0500 1451)                                     else {last_lease_cost.get(&phase).unwrap().get(&set).unwrap().0};
614408e5 (matthew    2021-11-10 23:51:03 -0500 1452)                                     if new_costs.get(&phase)==None{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1453)                                         new_costs.insert(phase,HashMap::new());
614408e5 (matthew    2021-11-10 23:51:03 -0500 1454)                                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1455)                                     let new_cost=cost_per_phase.get(&phase).unwrap().get(&set).unwrap()-past_cost_actual+(*set_phase_ref_cost as f64 * current_phase_alpha).round() as u64;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1456)                                 new_costs.get_mut(&phase).unwrap().insert(set,new_cost); 
09c93cae (matthew    2021-09-29 22:21:41 -0400 1457)                                   //if no lease adjustment can be made to keep the phase from being over budget 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1458)                                     if new_costs.get(&phase).unwrap().get(&set).unwrap()>budget_per_phase.get(&phase).unwrap(){
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1459)                                         adjust_lease=false;
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1460)                                         break;
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1461)                                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1462)                                      let remaining_budget = *budget_per_phase.get(&phase).unwrap()  - new_costs.get(&phase).unwrap().get(&set).unwrap(); 
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1463)                                            //if cost of last lease was zero i.e., no prior lease for phase, then alpha will be 1 and will not be adjusted
614408e5 (matthew    2021-11-10 23:51:03 -0500 1464)                                     let past_cost_max=if past_cost_actual!=0 {last_lease_cost.get(phase).unwrap().get(&set).unwrap().1} else {0};
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1465)                                      if past_cost_max!=0{
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1466)                                          //if previous long lease didn't fill phase, could be greater than one
614408e5 (matthew    2021-11-10 23:51:03 -0500 1467)                                         let set_phase_alpha=super::helpers::float_min(1.0,remaining_budget as f64/past_cost_max as f64);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1468)                                         if set_phase_alpha<=min_alpha{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1469)                                             let old_phase_ref=last_lease_cost.get(phase).unwrap().get(&set).unwrap().2;
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1470)                                             dual_leases.get(&old_phase_ref).unwrap().1;
2f68992c (matthew    2021-10-10 20:30:16 -0400 1471)                                               println!("Assigning adjusted dual lease {:x} with percentage {} to reference ({},{:x}) would not be meaningful.", 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1472)                                         new_lease.lease,set_phase_alpha,phase,old_phase_ref);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1473)                                                adjust_lease=false;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1474)                                               break;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1475)                                         }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1476)                                         //need the minimum alpha of any set in the phase
614408e5 (matthew    2021-11-10 23:51:03 -0500 1477)                                         else if set_phase_alpha<phase_alpha{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1478)                                             phase_alpha=set_phase_alpha;
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1479)                                         }
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1480) 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1481)                                         new_alpha.insert(phase,phase_alpha);
20d01f90 (matthew    2021-10-10 19:48:45 -0400 1482) 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1483)                                     }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1484)                                      
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1485)                                     
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1486)                                 }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1487)                                 //new costs is equal to old cost
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1488)                                 else{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1489)                                     if new_costs.get(&phase)==None{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1490)                                         new_costs.insert(&phase,HashMap::new());
614408e5 (matthew    2021-11-10 23:51:03 -0500 1491)                                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1492)                                     new_costs.get_mut(&phase).unwrap().insert(set,*cost_per_phase.get(&phase).unwrap().get(&set).unwrap());
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1493)                                 }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1494)                             }
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1495)                         }
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1496)                         if adjust_lease==true {
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1497)                             for phase in &phase_ids{
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1498)                                 //if adjusting lease
614408e5 (matthew    2021-11-10 23:51:03 -0500 1499)                                 for set in 0..num_sets{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1500)                                     if new_alpha.get(&phase)!=None{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1501)                                         let old_phase_cost_max=last_lease_cost.get(phase).unwrap().get(&set).unwrap().1;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1502)                                         let old_phase_ref=last_lease_cost.get(phase).unwrap().get(&set).unwrap().2;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1503)                                         let new_phase_cost=(old_phase_cost_max as f64*new_alpha.get(phase).unwrap()) as u64;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1504)                                        
614408e5 (matthew    2021-11-10 23:51:03 -0500 1505)                                         //if phase had a dual lease
614408e5 (matthew    2021-11-10 23:51:03 -0500 1506)                                         if dual_lease_phases.contains(phase){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1507)                                            dual_leases.insert(old_phase_ref,(*new_alpha.get(&phase).unwrap(),dual_leases.get(&old_phase_ref).unwrap().1));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1508)                                         }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1509)                                         //if we are not currently assigning a dual lease to this phase
614408e5 (matthew    2021-11-10 23:51:03 -0500 1510)                                         //generate dual lease from the past two lease values of the last reference assigned in this phase
614408e5 (matthew    2021-11-10 23:51:03 -0500 1511)                                         else if **phase!=new_lease.ref_id>>24{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1512)                                             //set prior single lease as long lease value with new alpha
614408e5 (matthew    2021-11-10 23:51:03 -0500 1513)                                             dual_leases.insert(old_phase_ref,(*new_alpha.get(&phase).unwrap(),past_lease_values.get(&old_phase_ref).unwrap().0));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1514)                                             //set the lease two references back as the short lease value
614408e5 (matthew    2021-11-10 23:51:03 -0500 1515)                                             leases.insert(old_phase_ref,past_lease_values.get(&old_phase_ref).unwrap().1);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1516)                                             dual_lease_phases.push(**phase);
614408e5 (matthew    2021-11-10 23:51:03 -0500 1517)                                         } 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1518) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1519)                                         last_lease_cost.get_mut(&phase).unwrap().insert(set,(new_phase_cost,old_phase_cost_max,old_phase_ref));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1520)                                         //update phase costs
614408e5 (matthew    2021-11-10 23:51:03 -0500 1521)                                         cost_per_phase.get_mut(&phase).unwrap().insert(set,*new_costs.get(&phase).unwrap().get(&set).unwrap()+new_phase_cost);
09c93cae (matthew    2021-09-29 22:21:41 -0400 1522)                                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1523)                                     //if not adjusting the lease
614408e5 (matthew    2021-11-10 23:51:03 -0500 1524)                                     else {
614408e5 (matthew    2021-11-10 23:51:03 -0500 1525)                                             //update phase costs
614408e5 (matthew    2021-11-10 23:51:03 -0500 1526)                                         cost_per_phase.get_mut(&phase).unwrap().insert(set,*new_costs.get(&phase).unwrap().get(&set).unwrap());
614408e5 (matthew    2021-11-10 23:51:03 -0500 1527)                                        //fix floating point precision error leading to "overallocation"
614408e5 (matthew    2021-11-10 23:51:03 -0500 1528)                                         if cost_per_phase.get(&phase).unwrap().get(&set).unwrap()>budget_per_phase.get(&phase).unwrap(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1529)                                             cost_per_phase.get_mut(&phase).unwrap().insert(set,*budget_per_phase.get(&phase).unwrap());
614408e5 (matthew    2021-11-10 23:51:03 -0500 1530)                                         }
09c93cae (matthew    2021-09-29 22:21:41 -0400 1531) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1532)                                     }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1533)                                 }
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1534)                             }
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1535)                             alpha=current_phase_alpha;
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1536)                         }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1537)                         else {
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1538)                             //if we can't assign a dual lease without overflowing a phase
614408e5 (matthew    2021-11-10 23:51:03 -0500 1539)                             //without adjustment of past dual leases, with adjustment of past dual leases, 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1540)                             //or in the the unlikely case a phase is full with no dual lease
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1541)                            
09c93cae (matthew    2021-09-29 22:21:41 -0400 1542)                               println!("Unable to assign lease {:x} with percentage {} to reference ({},{:x})", 
09c93cae (matthew    2021-09-29 22:21:41 -0400 1543)                                  new_lease.lease,current_phase_alpha,(new_lease.ref_id & 0xFF000000) >> 24, 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1544)                                  new_lease.ref_id & 0x00FFFFFF);
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1545)                                continue; 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1546)                         }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1547) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1548)                     }
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1549)                 }
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1550)               
2cff0195 (Ben Reber  2021-07-09 15:06:38 -0400 1551) 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1552)                 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1553)             
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1554)                 let phase=(new_lease.ref_id & 0xFF000000)>>24;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1555) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1556)                 //detect if set full
614408e5 (matthew    2021-11-10 23:51:03 -0500 1557)                 let mut set_full=false;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1558)                 for set in 0..num_sets{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1559)                     if cost_per_phase.get(&phase).unwrap().get(&set).unwrap()==budget_per_phase.get(&phase).unwrap(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1560)                         set_full=true;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1561)                         break;
614408e5 (matthew    2021-11-10 23:51:03 -0500 1562)                     }
614408e5 (matthew    2021-11-10 23:51:03 -0500 1563)                 }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1564)                 //if last lease was a dual lease with alpha of 1 that didn't fill the budget, then it is actually a short lease and adjustments can be made to ensure 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1565)                 //there is only 1 dual lease per phase.
614408e5 (matthew    2021-11-10 23:51:03 -0500 1566)                 if alpha==1.0 && set_full==false{
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1567)                     //update leases
614408e5 (matthew    2021-11-10 23:51:03 -0500 1568)                     leases.insert(new_lease.ref_id&0xFFFFFFFF,new_lease.lease);
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1569)                     //push new ppucs
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1570)                     let ppuc_vec = get_ppuc(new_lease.ref_id,
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1571)                                             new_lease.lease,
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1572)                                             ri_hists.ri_hists.get(&new_lease.ref_id).unwrap());
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1573) 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1574)                     for ppuc in ppuc_vec.iter(){
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1575)                         ppuc_tree.push(*ppuc);
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1576)                     }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1577)                     if verbose {
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1578)                         println!("Assigned lease {:x} to reference ({},{:x}).", 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1579)                                  new_lease.lease, (new_lease.ref_id & 0xFF000000) >> 24, 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1580)                                  new_lease.ref_id & 0x00FFFFFF);
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1581)                     }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1582) 
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1583)                 }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1584)                 //add dual lease
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1585)                 else{
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1586) 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1587)                     //store cost of dual lease and store cost of lease with no dual lease and the reference for that lease
614408e5 (matthew    2021-11-10 23:51:03 -0500 1588)                      for set in 0..num_sets{
89d73b4e (matthew    2021-11-17 18:43:03 -0500 1589)                         if last_lease_cost.get_mut(&phase)==None{
89d73b4e (matthew    2021-11-17 18:43:03 -0500 1590)                             last_lease_cost.entry(phase).or_insert(HashMap::new());
89d73b4e (matthew    2021-11-17 18:43:03 -0500 1591)                         }
89d73b4e (matthew    2021-11-17 18:43:03 -0500 1592) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1593)                       last_lease_cost.get_mut(&phase).unwrap().insert(set,((*new_phase_ref_cost.get(&phase).unwrap().get(&set).unwrap() as f64 *alpha).round() as u64,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1594)                         *new_phase_ref_cost.get(&phase).unwrap().get(&set).unwrap(),ref_id&0xFFFFFFFF));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1595)                     }  
614408e5 (matthew    2021-11-10 23:51:03 -0500 1596)                     
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1597)                    dual_lease_phases.push(phase);
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1598)                    //update dual lease HashMap
614408e5 (matthew    2021-11-10 23:51:03 -0500 1599)                     dual_leases.insert(new_lease.ref_id&0xFFFFFFFF,(alpha,new_lease.lease));
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1600)                     
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1601) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1602)                     
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1603)                     if verbose {
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1604)                         println!("Assigned dual lease ({:x},{}) to reference ({},{:x}).", 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1605)                                   new_lease.lease, 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1606)                                   alpha, 
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1607)                                   (new_lease.ref_id & 0xFF000000) >> 24,
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1608)                                   new_lease.ref_id & 0x00FFFFFF);
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1609)                     }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1610)                    
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1611)                 }
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1612)               
cfd71913 (matthew    2021-09-26 17:49:07 -0400 1613)             }//unacceptable lease
09c93cae (matthew    2021-09-29 22:21:41 -0400 1614)        
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1615)             if verbose & debug { 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1616)                 
177a91f6 (matthew    2021-09-25 04:20:29 -0400 1617)                 for (phase,num) in samples_per_phase.iter(){
614408e5 (matthew    2021-11-10 23:51:03 -0500 1618)                     for set in 0..num_sets{
614408e5 (matthew    2021-11-10 23:51:03 -0500 1619) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1620) 
614408e5 (matthew    2021-11-10 23:51:03 -0500 1621)                     println!("Debug: phase: {}. set: {} Allocation: {}",phase,set,
614408e5 (matthew    2021-11-10 23:51:03 -0500 1622)                         cost_per_phase.get(&phase).unwrap().get(&set).unwrap()  / (num*sample_rate));
614408e5 (matthew    2021-11-10 23:51:03 -0500 1623)                     }
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1624)                 }
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1625)                 /*
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1626)                     println!("Debug: phase: {}",phase);
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1627)                     println!("Debug:    cost_per_phase:   {:?}",
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1628)                              cost_per_phase.get(&phase).unwrap());
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1629)                     println!("Debug:    budget_per_phase: {:?}",
292ae658 (Ben Reber  2021-07-15 16:19:22 -0400 1630)                              budget_per_phase.get(&phase).unwrap());
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1631)                 }*/
2cff0195 (Ben Reber  2021-07-09 15:06:38 -0400 1632)             }
465fad7c (matthew    2022-01-20 14:01:55 -0500 1633) 
465fad7c (matthew    2022-01-20 14:01:55 -0500 1634) 
465fad7c (matthew    2022-01-20 14:01:55 -0500 1635)             if verbose {               
465fad7c (matthew    2022-01-20 14:01:55 -0500 1636)                 let mut hits_from_old_lease=0;
465fad7c (matthew    2022-01-20 14:01:55 -0500 1637)                 
465fad7c (matthew    2022-01-20 14:01:55 -0500 1638)                 if lease_hits.get(&new_lease.ref_id).unwrap().get(&old_lease)!=None{
465fad7c (matthew    2022-01-20 14:01:55 -0500 1639)                     hits_from_old_lease=*lease_hits.get(&new_lease.ref_id).unwrap().get(&old_lease).unwrap();
465fad7c (matthew    2022-01-20 14:01:55 -0500 1640)                 }
465fad7c (matthew    2022-01-20 14:01:55 -0500 1641)                 let mut hits_from_new_lease=*lease_hits.get(&new_lease.ref_id).unwrap().get(&new_lease.lease).unwrap();
465fad7c (matthew    2022-01-20 14:01:55 -0500 1642)                 let long_lease_percentage:f64;
465fad7c (matthew    2022-01-20 14:01:55 -0500 1643)                 if dual_leases.get(&new_lease.ref_id)!=None{
465fad7c (matthew    2022-01-20 14:01:55 -0500 1644)                     long_lease_percentage=dual_leases.get(&new_lease.ref_id).unwrap().0;
465fad7c (matthew    2022-01-20 14:01:55 -0500 1645)                     let hits_without_dual=hits_from_new_lease;
465fad7c (matthew    2022-01-20 14:01:55 -0500 1646)                     
465fad7c (matthew    2022-01-20 14:01:55 -0500 1647)                     hits_from_new_lease=hits_without_dual-(hits_without_dual as 
465fad7c (matthew    2022-01-20 14:01:55 -0500 1648)                         f64*(1.0-long_lease_percentage)) as u64+((1.0-long_lease_percentage)*hits_from_old_lease as f64)as u64;
465fad7c (matthew    2022-01-20 14:01:55 -0500 1649) 
465fad7c (matthew    2022-01-20 14:01:55 -0500 1650)                 }
465fad7c (matthew    2022-01-20 14:01:55 -0500 1651)                 println!("Additional hits from assigned lease:{}",(hits_from_new_lease-hits_from_old_lease)*sample_rate);
465fad7c (matthew    2022-01-20 14:01:55 -0500 1652) 
465fad7c (matthew    2022-01-20 14:01:55 -0500 1653)             }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1654)         }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1655)     }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1656) }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1657) 
^74c9c8c (Ben Reber  2021-06-28 10:59:15 -0400 1658) #[cfg(test)]
^74c9c8c (Ben Reber  2021-06-28 10:59:15 -0400 1659) mod tests {
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1660)     use std::collections::HashMap;
465fad7c (matthew    2022-01-20 14:01:55 -0500 1661)     
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1662)     use super::io::debug::*;
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1663)     use super::helpers::*;
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1664)     use super::lease_gen::*;
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1665) 
^74c9c8c (Ben Reber  2021-06-28 10:59:15 -0400 1666)     #[test]
^74c9c8c (Ben Reber  2021-06-28 10:59:15 -0400 1667)     fn it_works() {
^74c9c8c (Ben Reber  2021-06-28 10:59:15 -0400 1668)         assert_eq!(2 + 2, 4);
^74c9c8c (Ben Reber  2021-06-28 10:59:15 -0400 1669)     }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1670) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1671)     #[test]
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1672)     fn test_bin_search(){
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1673)         let a = vec![(0,0),(5,1),(120,2),(288,0),(1025,1)];
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1674)         assert_eq!(binary_search(&a,2),Some((5,1)));
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1675)         assert_eq!(binary_search(&a,120),Some((288,0)));
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1676)         assert_eq!(binary_search(&a,1024),Some((1025,1)));
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1677)         assert_eq!(binary_search(&a,2048),None);
f90180c6 (Ben Reber  2021-07-01 13:13:02 -0400 1678)         assert_eq!(binary_search(&a,1025),None);
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1679)     }
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1680) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1681)     #[test]
9fd8e536 (Ben Reber  2021-07-08 13:41:56 -0400 1682)     fn test_process_sample_head_cost(){
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1683)         let mut ri_hists = HashMap::new();
9fd8e536 (Ben Reber  2021-07-08 13:41:56 -0400 1684)         process_sample_head_cost(&mut ri_hists,1,12,20,(100000,1));
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1685)         let hist_struct = RIHists::new(ri_hists);
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1686) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1687)         assert_eq!(hist_struct.get_ref_ri_count(1,12),1);
9fd8e536 (Ben Reber  2021-07-08 13:41:56 -0400 1688)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,12,0),(12,0));
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1689) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1690)     }
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1691) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1692)     #[test]
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1693)     fn test_cross_phase_head_cost(){
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1694) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1695)         let mut ri_hists = HashMap::new();
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1696)         process_sample_head_cost(&mut ri_hists,1,12,8,(10,1)); //reference 1, phase 0
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1697)         let hist_struct = RIHists::new(ri_hists);
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1698) 
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1699)         assert_eq!(hist_struct.get_ref_ri_count(1,12),1);
9fd8e536 (Ben Reber  2021-07-08 13:41:56 -0400 1700)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,12,0),(2,0));
9fd8e536 (Ben Reber  2021-07-08 13:41:56 -0400 1701)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,12,1),(10,0));
eee0a36c (Ben Reber  2021-07-01 12:33:15 -0400 1702)     }
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1703) 
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1704)     #[test]
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1705)     fn test_get_ppuc(){
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1706)         let mut ri_hist = HashMap::new();
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1707) 
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1708)         ri_hist.insert(3,(1,HashMap::new()));
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1709)         ri_hist.insert(5,(7,HashMap::new()));
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1710)         ri_hist.insert(17,(4,HashMap::new()));
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1711)         ri_hist.insert(19,(3,HashMap::new()));
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1712)         let ppucs = get_ppuc(1,0,&ri_hist);
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1713)         println!("{:?}",ppucs);//According to Asplos19, the numbers are [.02,.11,.08,.09];
487c7cd7 (Ben Reber  2021-07-08 11:58:01 -0400 1714)     }
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1715) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1716) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1717)     #[test]
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1718)     fn test_process_sample_tail_cost(){
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1719)         let mut ri_hists = HashMap::new();
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1720)         let ri_short = 10;
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1721)         let ri_long = 100;
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1722)         let ri_very_long = 1000;
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1723)         process_sample_head_cost(&mut ri_hists,1,ri_short,10,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1724)         process_sample_head_cost(&mut ri_hists,1,ri_short,20,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1725)         process_sample_head_cost(&mut ri_hists,1,ri_long,200,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1726)         process_sample_head_cost(&mut ri_hists,1,ri_very_long,2200,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1727) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1728)         process_sample_tail_cost(&mut ri_hists,1,ri_short,10,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1729)         process_sample_tail_cost(&mut ri_hists,1,ri_short,20,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1730)         process_sample_tail_cost(&mut ri_hists,1,ri_long,200,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1731)         process_sample_tail_cost(&mut ri_hists,1,ri_very_long,2200,(10000,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1732) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1733)         let hist_struct = RIHists::new(ri_hists);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1734) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1735)        // print_ri_hists(&hist_struct);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1736)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,ri_short,0).1,20);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1737)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,ri_long,0).1,100);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1738)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,ri_very_long,0).1,0);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1739) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1740)     }
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1741) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1742)     //pub fn process_sample_head_cost(ri_hists: &mut HashMap<u64,HashMap<u64,(u64,HashMap<u64,(u64,u64)>)>>,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1743)      //p                 phase_id_ref: u64,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1744)         //p              ri: u64,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1745)            //p           use_time: u64,
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1746)               //p        next_phase_tuple: (u64,u64)){
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1747)     #[test]
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1748)     fn tail_cost_cross_phase(){
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1749)         let mut ri_hists = HashMap::new();
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1750)         process_sample_head_cost(&mut ri_hists,1,100,70,(100,1));
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1751)         process_sample_head_cost(&mut ri_hists,1,50,70,(100,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1752) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1753)         process_sample_tail_cost(&mut ri_hists,1,100,70,(100,1));
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1754)         process_sample_tail_cost(&mut ri_hists,1,50,70,(100,1));
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1755) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1756)         let hist_struct = RIHists::new(ri_hists);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1757) 
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1758)         print_ri_hists(&hist_struct);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1759)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,50,0).1,30);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1760)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,50,1).1,20);
89c13525 (Ben Reber  2021-07-08 16:28:33 -0400 1761)     }
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1762) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1763)     #[test]
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1764)     fn negative_ri(){
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1765)         let mut ri_hists = HashMap::new();
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1766)         process_sample_head_cost(&mut ri_hists,1, 50, 80, (100,1));
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1767)         process_sample_head_cost(&mut ri_hists,1,i32::max as u64, 90, (100,1));
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1768) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1769)         process_sample_tail_cost(&mut ri_hists,1, 50, 80, (100,1));
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1770)         process_sample_tail_cost(&mut ri_hists,1,i32::max as u64, 90, (100,1));
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1771)         let hist_struct = RIHists::new(ri_hists);
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1772) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1773)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,50,0).0,20);
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1774)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,50,1).0,30);
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1775)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,50,0).1,10);
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1776)         assert_eq!(hist_struct.get_ref_ri_phase_cost(1,50,1).1,40);
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1777) 
359e1ed9 (Ben Reber  2021-09-13 16:53:14 -0400 1778)     }
^74c9c8c (Ben Reber  2021-06-28 10:59:15 -0400 1779) }
