    Checking cshel v0.1.0 (/Users/ben/UR/Summer21/cshel)
warning: unused import: `ReaderBuilder`
 --> src/lib.rs:4:11
  |
4 | use csv::{ReaderBuilder};
  |           ^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `std::fmt`
 --> src/lib.rs:6:5
  |
6 | use std::fmt;
  |     ^^^^^^^^

warning: denote infinite loops with `loop { ... }`
   --> src/lib.rs:253:5
    |
253 |     while true{
    |     ^^^^^^^^^^ help: use `loop`
    |
    = note: `#[warn(while_true)]` on by default

error[E0308]: mismatched types
   --> src/lib.rs:259:38
    |
259 |         while new_lease.old_lease != leases.get(&new_lease.ref_id).unwrap(){
    |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |                                      |
    |                                      expected `u64`, found `&u64`
    |                                      help: consider dereferencing the borrow: `*leases.get(&new_lease.ref_id).unwrap()`

error[E0308]: mismatched types
   --> src/lib.rs:271:47
    |
271 |             let new_cost = get_phase_ref_cost(phase,new_lease.0,old_lease,new_lease.1,ri_hists);
    |                                               ^^^^^ expected `u64`, found `&&u64`

error[E0609]: no field `0` on type `PPUC`
   --> src/lib.rs:271:63
    |
271 |             let new_cost = get_phase_ref_cost(phase,new_lease.0,old_lease,new_lease.1,ri_hists);
    |                                                               ^ unknown field
    |
    = note: available fields are: `ppuc`, `lease`, `old_lease`, `ref_id`

error[E0308]: mismatched types
   --> src/lib.rs:271:65
    |
271 |             let new_cost = get_phase_ref_cost(phase,new_lease.0,old_lease,new_lease.1,ri_hists);
    |                                                                 ^^^^^^^^^
    |                                                                 |
    |                                                                 expected `u64`, found `&u64`
    |                                                                 help: consider dereferencing the borrow: `*old_lease`

error[E0609]: no field `1` on type `PPUC`
   --> src/lib.rs:271:85
    |
271 |             let new_cost = get_phase_ref_cost(phase,new_lease.0,old_lease,new_lease.1,ri_hists);
    |                                                                                     ^ unknown field
    |
    = note: available fields are: `ppuc`, `lease`, `old_lease`, `ref_id`

error[E0308]: mismatched types
   --> src/lib.rs:272:66
    |
272 |             if (new_cost + cost_per_phase.get(phase).unwrap()) > *budget_per_phase.get(phase).unwrap(){
    |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `u64`
    |
help: you can convert a `u64` to an `i64` and panic if the converted value doesn't fit
    |
272 |             if (new_cost + cost_per_phase.get(phase).unwrap()) > (*budget_per_phase.get(phase).unwrap()).try_into().unwrap(){
    |                                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0609]: no field `0` on type `PPUC`
   --> src/lib.rs:285:38
    |
285 |             leases.insert(&new_lease.0,new_lease.1);
    |                                      ^ unknown field
    |
    = note: available fields are: `ppuc`, `lease`, `old_lease`, `ref_id`

error[E0609]: no field `1` on type `PPUC`
   --> src/lib.rs:285:50
    |
285 |             leases.insert(&new_lease.0,new_lease.1);
    |                                                  ^ unknown field
    |
    = note: available fields are: `ppuc`, `lease`, `old_lease`, `ref_id`

error[E0308]: mismatched types
   --> src/lib.rs:253:5
    |
230 |                 samples_per_phase : HashMap<u64,u64>) -> HashMap<i64,u64> {
    |                                                          ---------------- expected `HashMap<i64, u64>` because of return type
...
253 | /     while true{
254 | |         new_lease = match ppuc_tree.pop(){
255 | |             Some(i) => i,
256 | |             None => return leases,
...   |
290 | |         }//dual lease
291 | |     }
    | |_____^ expected struct `HashMap`, found `()`
    |
    = note: expected struct `HashMap<i64, u64>`
            found unit type `()`

error[E0277]: the trait bound `&&i64: Borrow<i64>` is not satisfied
   --> src/lib.rs:334:37
    |
334 |             ppuc:((*lease_hit_table.get(k as &i64).unwrap()-*lease_hit_table.get(&base_lease).unwrap()) as f32/
    |                                     ^^^ the trait `Borrow<i64>` is not implemented for `&&i64`

error[E0277]: the trait bound `&&i64: Borrow<i64>` is not satisfied
   --> src/lib.rs:334:78
    |
334 |             ppuc:((*lease_hit_table.get(k as &i64).unwrap()-*lease_hit_table.get(&base_lease).unwrap()) as f32/
    |                                                                              ^^^ the trait `Borrow<i64>` is not implemented for `&&i64`

error[E0277]: the trait bound `&&i64: Borrow<i64>` is not satisfied
   --> src/lib.rs:335:38
    |
335 |                   (*lease_cost_table.get(k as &i64).unwrap()-*lease_cost_table.get(&base_lease).unwrap())as f32),
    |                                      ^^^ the trait `Borrow<i64>` is not implemented for `&&i64`

error[E0277]: the trait bound `&&i64: Borrow<i64>` is not satisfied
   --> src/lib.rs:335:80
    |
335 |                   (*lease_cost_table.get(k as &i64).unwrap()-*lease_cost_table.get(&base_lease).unwrap())as f32),
    |                                                                                ^^^ the trait `Borrow<i64>` is not implemented for `&&i64`

error[E0308]: mismatched types
   --> src/lib.rs:336:19
    |
336 |             lease:k,
    |                   ^ expected `u64`, found `&i64`

error[E0308]: mismatched types
   --> src/lib.rs:337:24
    |
337 |             old_lease: base_lease,
    |                        ^^^^^^^^^^ expected `u64`, found `i64`

error[E0308]: mismatched types
   --> src/lib.rs:332:5
    |
311 |               ref_ri_hist: HashMap<i64,(u64,HashMap<i64,i64>)>) -> Vec<PPUC>{
    |                                                                    --------- expected `Vec<PPUC>` because of return type
...
332 | /     ri_hist.iter().map(|(k,v)| k).filter(|k| **k > base_lease).map(
333 | |         |k| PPUC {
334 | |             ppuc:((*lease_hit_table.get(k as &i64).unwrap()-*lease_hit_table.get(&base_lease).unwrap()) as f32/
335 | |                   (*lease_cost_table.get(k as &i64).unwrap()-*lease_cost_table.get(&base_lease).unwrap())as f32),
...   |
339 | |         }
340 | |     )
    | |_____^ expected struct `Vec`, found struct `std::iter::Map`
    |
    = note: expected struct `Vec<PPUC>`
               found struct `std::iter::Map<Filter<std::iter::Map<std::slice::Iter<'_, (i64, u64)>, [closure@src/lib.rs:332:24: 332:33]>, [closure@src/lib.rs:332:42: 332:62]>, [closure@src/lib.rs:333:9: 339:10]>`

error[E0606]: casting `&i64` as `u64` is invalid
   --> src/lib.rs:325:30
    |
325 |         head_cost += count * (ri as u64);
    |                              ^--^^^^^^^^
    |                              ||
    |                              |help: dereference the expression: `*ri`
    |                              cannot cast `&i64` as `u64`

error[E0606]: casting `&i64` as `u64` is invalid
   --> src/lib.rs:326:48
    |
326 |         let tail_cost = (total_count - hits) * (ri as u64);
    |                                                ^--^^^^^^^^
    |                                                ||
    |                                                |help: dereference the expression: `*ri`
    |                                                cannot cast `&i64` as `u64`

error: aborting due to 18 previous errors; 3 warnings emitted

Some errors have detailed explanations: E0277, E0308, E0606, E0609.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `cshel`

To learn more, run the command again with --verbose.
